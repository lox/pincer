// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: proto/pincer/protocol/v1/protocol.proto

package protocolv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/lox/pincer/gen/proto/pincer/protocol/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// AuthServiceName is the fully-qualified name of the AuthService service.
	AuthServiceName = "pincer.protocol.v1.AuthService"
	// DevicesServiceName is the fully-qualified name of the DevicesService service.
	DevicesServiceName = "pincer.protocol.v1.DevicesService"
	// ThreadsServiceName is the fully-qualified name of the ThreadsService service.
	ThreadsServiceName = "pincer.protocol.v1.ThreadsService"
	// TurnsServiceName is the fully-qualified name of the TurnsService service.
	TurnsServiceName = "pincer.protocol.v1.TurnsService"
	// EventsServiceName is the fully-qualified name of the EventsService service.
	EventsServiceName = "pincer.protocol.v1.EventsService"
	// ApprovalsServiceName is the fully-qualified name of the ApprovalsService service.
	ApprovalsServiceName = "pincer.protocol.v1.ApprovalsService"
	// JobsServiceName is the fully-qualified name of the JobsService service.
	JobsServiceName = "pincer.protocol.v1.JobsService"
	// SchedulesServiceName is the fully-qualified name of the SchedulesService service.
	SchedulesServiceName = "pincer.protocol.v1.SchedulesService"
	// SystemServiceName is the fully-qualified name of the SystemService service.
	SystemServiceName = "pincer.protocol.v1.SystemService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// AuthServiceCreatePairingCodeProcedure is the fully-qualified name of the AuthService's
	// CreatePairingCode RPC.
	AuthServiceCreatePairingCodeProcedure = "/pincer.protocol.v1.AuthService/CreatePairingCode"
	// AuthServiceBindPairingCodeProcedure is the fully-qualified name of the AuthService's
	// BindPairingCode RPC.
	AuthServiceBindPairingCodeProcedure = "/pincer.protocol.v1.AuthService/BindPairingCode"
	// AuthServiceRotateTokenProcedure is the fully-qualified name of the AuthService's RotateToken RPC.
	AuthServiceRotateTokenProcedure = "/pincer.protocol.v1.AuthService/RotateToken"
	// DevicesServiceListDevicesProcedure is the fully-qualified name of the DevicesService's
	// ListDevices RPC.
	DevicesServiceListDevicesProcedure = "/pincer.protocol.v1.DevicesService/ListDevices"
	// DevicesServiceRevokeDeviceProcedure is the fully-qualified name of the DevicesService's
	// RevokeDevice RPC.
	DevicesServiceRevokeDeviceProcedure = "/pincer.protocol.v1.DevicesService/RevokeDevice"
	// ThreadsServiceCreateThreadProcedure is the fully-qualified name of the ThreadsService's
	// CreateThread RPC.
	ThreadsServiceCreateThreadProcedure = "/pincer.protocol.v1.ThreadsService/CreateThread"
	// ThreadsServiceListThreadsProcedure is the fully-qualified name of the ThreadsService's
	// ListThreads RPC.
	ThreadsServiceListThreadsProcedure = "/pincer.protocol.v1.ThreadsService/ListThreads"
	// ThreadsServiceGetThreadSnapshotProcedure is the fully-qualified name of the ThreadsService's
	// GetThreadSnapshot RPC.
	ThreadsServiceGetThreadSnapshotProcedure = "/pincer.protocol.v1.ThreadsService/GetThreadSnapshot"
	// ThreadsServiceListThreadMessagesProcedure is the fully-qualified name of the ThreadsService's
	// ListThreadMessages RPC.
	ThreadsServiceListThreadMessagesProcedure = "/pincer.protocol.v1.ThreadsService/ListThreadMessages"
	// ThreadsServiceDeleteThreadProcedure is the fully-qualified name of the ThreadsService's
	// DeleteThread RPC.
	ThreadsServiceDeleteThreadProcedure = "/pincer.protocol.v1.ThreadsService/DeleteThread"
	// TurnsServiceSendTurnProcedure is the fully-qualified name of the TurnsService's SendTurn RPC.
	TurnsServiceSendTurnProcedure = "/pincer.protocol.v1.TurnsService/SendTurn"
	// TurnsServiceStartTurnProcedure is the fully-qualified name of the TurnsService's StartTurn RPC.
	TurnsServiceStartTurnProcedure = "/pincer.protocol.v1.TurnsService/StartTurn"
	// EventsServiceWatchThreadProcedure is the fully-qualified name of the EventsService's WatchThread
	// RPC.
	EventsServiceWatchThreadProcedure = "/pincer.protocol.v1.EventsService/WatchThread"
	// ApprovalsServiceListApprovalsProcedure is the fully-qualified name of the ApprovalsService's
	// ListApprovals RPC.
	ApprovalsServiceListApprovalsProcedure = "/pincer.protocol.v1.ApprovalsService/ListApprovals"
	// ApprovalsServiceApproveActionProcedure is the fully-qualified name of the ApprovalsService's
	// ApproveAction RPC.
	ApprovalsServiceApproveActionProcedure = "/pincer.protocol.v1.ApprovalsService/ApproveAction"
	// ApprovalsServiceRejectActionProcedure is the fully-qualified name of the ApprovalsService's
	// RejectAction RPC.
	ApprovalsServiceRejectActionProcedure = "/pincer.protocol.v1.ApprovalsService/RejectAction"
	// JobsServiceListJobsProcedure is the fully-qualified name of the JobsService's ListJobs RPC.
	JobsServiceListJobsProcedure = "/pincer.protocol.v1.JobsService/ListJobs"
	// JobsServiceCreateJobProcedure is the fully-qualified name of the JobsService's CreateJob RPC.
	JobsServiceCreateJobProcedure = "/pincer.protocol.v1.JobsService/CreateJob"
	// JobsServiceGetJobProcedure is the fully-qualified name of the JobsService's GetJob RPC.
	JobsServiceGetJobProcedure = "/pincer.protocol.v1.JobsService/GetJob"
	// JobsServiceCancelJobProcedure is the fully-qualified name of the JobsService's CancelJob RPC.
	JobsServiceCancelJobProcedure = "/pincer.protocol.v1.JobsService/CancelJob"
	// SchedulesServiceListSchedulesProcedure is the fully-qualified name of the SchedulesService's
	// ListSchedules RPC.
	SchedulesServiceListSchedulesProcedure = "/pincer.protocol.v1.SchedulesService/ListSchedules"
	// SchedulesServiceCreateScheduleProcedure is the fully-qualified name of the SchedulesService's
	// CreateSchedule RPC.
	SchedulesServiceCreateScheduleProcedure = "/pincer.protocol.v1.SchedulesService/CreateSchedule"
	// SchedulesServiceUpdateScheduleProcedure is the fully-qualified name of the SchedulesService's
	// UpdateSchedule RPC.
	SchedulesServiceUpdateScheduleProcedure = "/pincer.protocol.v1.SchedulesService/UpdateSchedule"
	// SchedulesServiceRunScheduleNowProcedure is the fully-qualified name of the SchedulesService's
	// RunScheduleNow RPC.
	SchedulesServiceRunScheduleNowProcedure = "/pincer.protocol.v1.SchedulesService/RunScheduleNow"
	// SystemServiceGetPolicySummaryProcedure is the fully-qualified name of the SystemService's
	// GetPolicySummary RPC.
	SystemServiceGetPolicySummaryProcedure = "/pincer.protocol.v1.SystemService/GetPolicySummary"
	// SystemServiceListAuditProcedure is the fully-qualified name of the SystemService's ListAudit RPC.
	SystemServiceListAuditProcedure = "/pincer.protocol.v1.SystemService/ListAudit"
	// SystemServiceListNotificationsProcedure is the fully-qualified name of the SystemService's
	// ListNotifications RPC.
	SystemServiceListNotificationsProcedure = "/pincer.protocol.v1.SystemService/ListNotifications"
)

// AuthServiceClient is a client for the pincer.protocol.v1.AuthService service.
type AuthServiceClient interface {
	CreatePairingCode(context.Context, *connect.Request[v1.CreatePairingCodeRequest]) (*connect.Response[v1.CreatePairingCodeResponse], error)
	BindPairingCode(context.Context, *connect.Request[v1.BindPairingCodeRequest]) (*connect.Response[v1.BindPairingCodeResponse], error)
	RotateToken(context.Context, *connect.Request[v1.RotateTokenRequest]) (*connect.Response[v1.RotateTokenResponse], error)
}

// NewAuthServiceClient constructs a client for the pincer.protocol.v1.AuthService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAuthServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AuthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	authServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("AuthService").Methods()
	return &authServiceClient{
		createPairingCode: connect.NewClient[v1.CreatePairingCodeRequest, v1.CreatePairingCodeResponse](
			httpClient,
			baseURL+AuthServiceCreatePairingCodeProcedure,
			connect.WithSchema(authServiceMethods.ByName("CreatePairingCode")),
			connect.WithClientOptions(opts...),
		),
		bindPairingCode: connect.NewClient[v1.BindPairingCodeRequest, v1.BindPairingCodeResponse](
			httpClient,
			baseURL+AuthServiceBindPairingCodeProcedure,
			connect.WithSchema(authServiceMethods.ByName("BindPairingCode")),
			connect.WithClientOptions(opts...),
		),
		rotateToken: connect.NewClient[v1.RotateTokenRequest, v1.RotateTokenResponse](
			httpClient,
			baseURL+AuthServiceRotateTokenProcedure,
			connect.WithSchema(authServiceMethods.ByName("RotateToken")),
			connect.WithClientOptions(opts...),
		),
	}
}

// authServiceClient implements AuthServiceClient.
type authServiceClient struct {
	createPairingCode *connect.Client[v1.CreatePairingCodeRequest, v1.CreatePairingCodeResponse]
	bindPairingCode   *connect.Client[v1.BindPairingCodeRequest, v1.BindPairingCodeResponse]
	rotateToken       *connect.Client[v1.RotateTokenRequest, v1.RotateTokenResponse]
}

// CreatePairingCode calls pincer.protocol.v1.AuthService.CreatePairingCode.
func (c *authServiceClient) CreatePairingCode(ctx context.Context, req *connect.Request[v1.CreatePairingCodeRequest]) (*connect.Response[v1.CreatePairingCodeResponse], error) {
	return c.createPairingCode.CallUnary(ctx, req)
}

// BindPairingCode calls pincer.protocol.v1.AuthService.BindPairingCode.
func (c *authServiceClient) BindPairingCode(ctx context.Context, req *connect.Request[v1.BindPairingCodeRequest]) (*connect.Response[v1.BindPairingCodeResponse], error) {
	return c.bindPairingCode.CallUnary(ctx, req)
}

// RotateToken calls pincer.protocol.v1.AuthService.RotateToken.
func (c *authServiceClient) RotateToken(ctx context.Context, req *connect.Request[v1.RotateTokenRequest]) (*connect.Response[v1.RotateTokenResponse], error) {
	return c.rotateToken.CallUnary(ctx, req)
}

// AuthServiceHandler is an implementation of the pincer.protocol.v1.AuthService service.
type AuthServiceHandler interface {
	CreatePairingCode(context.Context, *connect.Request[v1.CreatePairingCodeRequest]) (*connect.Response[v1.CreatePairingCodeResponse], error)
	BindPairingCode(context.Context, *connect.Request[v1.BindPairingCodeRequest]) (*connect.Response[v1.BindPairingCodeResponse], error)
	RotateToken(context.Context, *connect.Request[v1.RotateTokenRequest]) (*connect.Response[v1.RotateTokenResponse], error)
}

// NewAuthServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAuthServiceHandler(svc AuthServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	authServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("AuthService").Methods()
	authServiceCreatePairingCodeHandler := connect.NewUnaryHandler(
		AuthServiceCreatePairingCodeProcedure,
		svc.CreatePairingCode,
		connect.WithSchema(authServiceMethods.ByName("CreatePairingCode")),
		connect.WithHandlerOptions(opts...),
	)
	authServiceBindPairingCodeHandler := connect.NewUnaryHandler(
		AuthServiceBindPairingCodeProcedure,
		svc.BindPairingCode,
		connect.WithSchema(authServiceMethods.ByName("BindPairingCode")),
		connect.WithHandlerOptions(opts...),
	)
	authServiceRotateTokenHandler := connect.NewUnaryHandler(
		AuthServiceRotateTokenProcedure,
		svc.RotateToken,
		connect.WithSchema(authServiceMethods.ByName("RotateToken")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.AuthService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AuthServiceCreatePairingCodeProcedure:
			authServiceCreatePairingCodeHandler.ServeHTTP(w, r)
		case AuthServiceBindPairingCodeProcedure:
			authServiceBindPairingCodeHandler.ServeHTTP(w, r)
		case AuthServiceRotateTokenProcedure:
			authServiceRotateTokenHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAuthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAuthServiceHandler struct{}

func (UnimplementedAuthServiceHandler) CreatePairingCode(context.Context, *connect.Request[v1.CreatePairingCodeRequest]) (*connect.Response[v1.CreatePairingCodeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.AuthService.CreatePairingCode is not implemented"))
}

func (UnimplementedAuthServiceHandler) BindPairingCode(context.Context, *connect.Request[v1.BindPairingCodeRequest]) (*connect.Response[v1.BindPairingCodeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.AuthService.BindPairingCode is not implemented"))
}

func (UnimplementedAuthServiceHandler) RotateToken(context.Context, *connect.Request[v1.RotateTokenRequest]) (*connect.Response[v1.RotateTokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.AuthService.RotateToken is not implemented"))
}

// DevicesServiceClient is a client for the pincer.protocol.v1.DevicesService service.
type DevicesServiceClient interface {
	ListDevices(context.Context, *connect.Request[v1.ListDevicesRequest]) (*connect.Response[v1.ListDevicesResponse], error)
	RevokeDevice(context.Context, *connect.Request[v1.RevokeDeviceRequest]) (*connect.Response[v1.RevokeDeviceResponse], error)
}

// NewDevicesServiceClient constructs a client for the pincer.protocol.v1.DevicesService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewDevicesServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) DevicesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	devicesServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("DevicesService").Methods()
	return &devicesServiceClient{
		listDevices: connect.NewClient[v1.ListDevicesRequest, v1.ListDevicesResponse](
			httpClient,
			baseURL+DevicesServiceListDevicesProcedure,
			connect.WithSchema(devicesServiceMethods.ByName("ListDevices")),
			connect.WithClientOptions(opts...),
		),
		revokeDevice: connect.NewClient[v1.RevokeDeviceRequest, v1.RevokeDeviceResponse](
			httpClient,
			baseURL+DevicesServiceRevokeDeviceProcedure,
			connect.WithSchema(devicesServiceMethods.ByName("RevokeDevice")),
			connect.WithClientOptions(opts...),
		),
	}
}

// devicesServiceClient implements DevicesServiceClient.
type devicesServiceClient struct {
	listDevices  *connect.Client[v1.ListDevicesRequest, v1.ListDevicesResponse]
	revokeDevice *connect.Client[v1.RevokeDeviceRequest, v1.RevokeDeviceResponse]
}

// ListDevices calls pincer.protocol.v1.DevicesService.ListDevices.
func (c *devicesServiceClient) ListDevices(ctx context.Context, req *connect.Request[v1.ListDevicesRequest]) (*connect.Response[v1.ListDevicesResponse], error) {
	return c.listDevices.CallUnary(ctx, req)
}

// RevokeDevice calls pincer.protocol.v1.DevicesService.RevokeDevice.
func (c *devicesServiceClient) RevokeDevice(ctx context.Context, req *connect.Request[v1.RevokeDeviceRequest]) (*connect.Response[v1.RevokeDeviceResponse], error) {
	return c.revokeDevice.CallUnary(ctx, req)
}

// DevicesServiceHandler is an implementation of the pincer.protocol.v1.DevicesService service.
type DevicesServiceHandler interface {
	ListDevices(context.Context, *connect.Request[v1.ListDevicesRequest]) (*connect.Response[v1.ListDevicesResponse], error)
	RevokeDevice(context.Context, *connect.Request[v1.RevokeDeviceRequest]) (*connect.Response[v1.RevokeDeviceResponse], error)
}

// NewDevicesServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewDevicesServiceHandler(svc DevicesServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	devicesServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("DevicesService").Methods()
	devicesServiceListDevicesHandler := connect.NewUnaryHandler(
		DevicesServiceListDevicesProcedure,
		svc.ListDevices,
		connect.WithSchema(devicesServiceMethods.ByName("ListDevices")),
		connect.WithHandlerOptions(opts...),
	)
	devicesServiceRevokeDeviceHandler := connect.NewUnaryHandler(
		DevicesServiceRevokeDeviceProcedure,
		svc.RevokeDevice,
		connect.WithSchema(devicesServiceMethods.ByName("RevokeDevice")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.DevicesService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case DevicesServiceListDevicesProcedure:
			devicesServiceListDevicesHandler.ServeHTTP(w, r)
		case DevicesServiceRevokeDeviceProcedure:
			devicesServiceRevokeDeviceHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedDevicesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedDevicesServiceHandler struct{}

func (UnimplementedDevicesServiceHandler) ListDevices(context.Context, *connect.Request[v1.ListDevicesRequest]) (*connect.Response[v1.ListDevicesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.DevicesService.ListDevices is not implemented"))
}

func (UnimplementedDevicesServiceHandler) RevokeDevice(context.Context, *connect.Request[v1.RevokeDeviceRequest]) (*connect.Response[v1.RevokeDeviceResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.DevicesService.RevokeDevice is not implemented"))
}

// ThreadsServiceClient is a client for the pincer.protocol.v1.ThreadsService service.
type ThreadsServiceClient interface {
	CreateThread(context.Context, *connect.Request[v1.CreateThreadRequest]) (*connect.Response[v1.CreateThreadResponse], error)
	ListThreads(context.Context, *connect.Request[v1.ListThreadsRequest]) (*connect.Response[v1.ListThreadsResponse], error)
	GetThreadSnapshot(context.Context, *connect.Request[v1.GetThreadSnapshotRequest]) (*connect.Response[v1.GetThreadSnapshotResponse], error)
	ListThreadMessages(context.Context, *connect.Request[v1.ListThreadMessagesRequest]) (*connect.Response[v1.ListThreadMessagesResponse], error)
	DeleteThread(context.Context, *connect.Request[v1.DeleteThreadRequest]) (*connect.Response[v1.DeleteThreadResponse], error)
}

// NewThreadsServiceClient constructs a client for the pincer.protocol.v1.ThreadsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewThreadsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ThreadsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	threadsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("ThreadsService").Methods()
	return &threadsServiceClient{
		createThread: connect.NewClient[v1.CreateThreadRequest, v1.CreateThreadResponse](
			httpClient,
			baseURL+ThreadsServiceCreateThreadProcedure,
			connect.WithSchema(threadsServiceMethods.ByName("CreateThread")),
			connect.WithClientOptions(opts...),
		),
		listThreads: connect.NewClient[v1.ListThreadsRequest, v1.ListThreadsResponse](
			httpClient,
			baseURL+ThreadsServiceListThreadsProcedure,
			connect.WithSchema(threadsServiceMethods.ByName("ListThreads")),
			connect.WithClientOptions(opts...),
		),
		getThreadSnapshot: connect.NewClient[v1.GetThreadSnapshotRequest, v1.GetThreadSnapshotResponse](
			httpClient,
			baseURL+ThreadsServiceGetThreadSnapshotProcedure,
			connect.WithSchema(threadsServiceMethods.ByName("GetThreadSnapshot")),
			connect.WithClientOptions(opts...),
		),
		listThreadMessages: connect.NewClient[v1.ListThreadMessagesRequest, v1.ListThreadMessagesResponse](
			httpClient,
			baseURL+ThreadsServiceListThreadMessagesProcedure,
			connect.WithSchema(threadsServiceMethods.ByName("ListThreadMessages")),
			connect.WithClientOptions(opts...),
		),
		deleteThread: connect.NewClient[v1.DeleteThreadRequest, v1.DeleteThreadResponse](
			httpClient,
			baseURL+ThreadsServiceDeleteThreadProcedure,
			connect.WithSchema(threadsServiceMethods.ByName("DeleteThread")),
			connect.WithClientOptions(opts...),
		),
	}
}

// threadsServiceClient implements ThreadsServiceClient.
type threadsServiceClient struct {
	createThread       *connect.Client[v1.CreateThreadRequest, v1.CreateThreadResponse]
	listThreads        *connect.Client[v1.ListThreadsRequest, v1.ListThreadsResponse]
	getThreadSnapshot  *connect.Client[v1.GetThreadSnapshotRequest, v1.GetThreadSnapshotResponse]
	listThreadMessages *connect.Client[v1.ListThreadMessagesRequest, v1.ListThreadMessagesResponse]
	deleteThread       *connect.Client[v1.DeleteThreadRequest, v1.DeleteThreadResponse]
}

// CreateThread calls pincer.protocol.v1.ThreadsService.CreateThread.
func (c *threadsServiceClient) CreateThread(ctx context.Context, req *connect.Request[v1.CreateThreadRequest]) (*connect.Response[v1.CreateThreadResponse], error) {
	return c.createThread.CallUnary(ctx, req)
}

// ListThreads calls pincer.protocol.v1.ThreadsService.ListThreads.
func (c *threadsServiceClient) ListThreads(ctx context.Context, req *connect.Request[v1.ListThreadsRequest]) (*connect.Response[v1.ListThreadsResponse], error) {
	return c.listThreads.CallUnary(ctx, req)
}

// GetThreadSnapshot calls pincer.protocol.v1.ThreadsService.GetThreadSnapshot.
func (c *threadsServiceClient) GetThreadSnapshot(ctx context.Context, req *connect.Request[v1.GetThreadSnapshotRequest]) (*connect.Response[v1.GetThreadSnapshotResponse], error) {
	return c.getThreadSnapshot.CallUnary(ctx, req)
}

// ListThreadMessages calls pincer.protocol.v1.ThreadsService.ListThreadMessages.
func (c *threadsServiceClient) ListThreadMessages(ctx context.Context, req *connect.Request[v1.ListThreadMessagesRequest]) (*connect.Response[v1.ListThreadMessagesResponse], error) {
	return c.listThreadMessages.CallUnary(ctx, req)
}

// DeleteThread calls pincer.protocol.v1.ThreadsService.DeleteThread.
func (c *threadsServiceClient) DeleteThread(ctx context.Context, req *connect.Request[v1.DeleteThreadRequest]) (*connect.Response[v1.DeleteThreadResponse], error) {
	return c.deleteThread.CallUnary(ctx, req)
}

// ThreadsServiceHandler is an implementation of the pincer.protocol.v1.ThreadsService service.
type ThreadsServiceHandler interface {
	CreateThread(context.Context, *connect.Request[v1.CreateThreadRequest]) (*connect.Response[v1.CreateThreadResponse], error)
	ListThreads(context.Context, *connect.Request[v1.ListThreadsRequest]) (*connect.Response[v1.ListThreadsResponse], error)
	GetThreadSnapshot(context.Context, *connect.Request[v1.GetThreadSnapshotRequest]) (*connect.Response[v1.GetThreadSnapshotResponse], error)
	ListThreadMessages(context.Context, *connect.Request[v1.ListThreadMessagesRequest]) (*connect.Response[v1.ListThreadMessagesResponse], error)
	DeleteThread(context.Context, *connect.Request[v1.DeleteThreadRequest]) (*connect.Response[v1.DeleteThreadResponse], error)
}

// NewThreadsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewThreadsServiceHandler(svc ThreadsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	threadsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("ThreadsService").Methods()
	threadsServiceCreateThreadHandler := connect.NewUnaryHandler(
		ThreadsServiceCreateThreadProcedure,
		svc.CreateThread,
		connect.WithSchema(threadsServiceMethods.ByName("CreateThread")),
		connect.WithHandlerOptions(opts...),
	)
	threadsServiceListThreadsHandler := connect.NewUnaryHandler(
		ThreadsServiceListThreadsProcedure,
		svc.ListThreads,
		connect.WithSchema(threadsServiceMethods.ByName("ListThreads")),
		connect.WithHandlerOptions(opts...),
	)
	threadsServiceGetThreadSnapshotHandler := connect.NewUnaryHandler(
		ThreadsServiceGetThreadSnapshotProcedure,
		svc.GetThreadSnapshot,
		connect.WithSchema(threadsServiceMethods.ByName("GetThreadSnapshot")),
		connect.WithHandlerOptions(opts...),
	)
	threadsServiceListThreadMessagesHandler := connect.NewUnaryHandler(
		ThreadsServiceListThreadMessagesProcedure,
		svc.ListThreadMessages,
		connect.WithSchema(threadsServiceMethods.ByName("ListThreadMessages")),
		connect.WithHandlerOptions(opts...),
	)
	threadsServiceDeleteThreadHandler := connect.NewUnaryHandler(
		ThreadsServiceDeleteThreadProcedure,
		svc.DeleteThread,
		connect.WithSchema(threadsServiceMethods.ByName("DeleteThread")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.ThreadsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ThreadsServiceCreateThreadProcedure:
			threadsServiceCreateThreadHandler.ServeHTTP(w, r)
		case ThreadsServiceListThreadsProcedure:
			threadsServiceListThreadsHandler.ServeHTTP(w, r)
		case ThreadsServiceGetThreadSnapshotProcedure:
			threadsServiceGetThreadSnapshotHandler.ServeHTTP(w, r)
		case ThreadsServiceListThreadMessagesProcedure:
			threadsServiceListThreadMessagesHandler.ServeHTTP(w, r)
		case ThreadsServiceDeleteThreadProcedure:
			threadsServiceDeleteThreadHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedThreadsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedThreadsServiceHandler struct{}

func (UnimplementedThreadsServiceHandler) CreateThread(context.Context, *connect.Request[v1.CreateThreadRequest]) (*connect.Response[v1.CreateThreadResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ThreadsService.CreateThread is not implemented"))
}

func (UnimplementedThreadsServiceHandler) ListThreads(context.Context, *connect.Request[v1.ListThreadsRequest]) (*connect.Response[v1.ListThreadsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ThreadsService.ListThreads is not implemented"))
}

func (UnimplementedThreadsServiceHandler) GetThreadSnapshot(context.Context, *connect.Request[v1.GetThreadSnapshotRequest]) (*connect.Response[v1.GetThreadSnapshotResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ThreadsService.GetThreadSnapshot is not implemented"))
}

func (UnimplementedThreadsServiceHandler) ListThreadMessages(context.Context, *connect.Request[v1.ListThreadMessagesRequest]) (*connect.Response[v1.ListThreadMessagesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ThreadsService.ListThreadMessages is not implemented"))
}

func (UnimplementedThreadsServiceHandler) DeleteThread(context.Context, *connect.Request[v1.DeleteThreadRequest]) (*connect.Response[v1.DeleteThreadResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ThreadsService.DeleteThread is not implemented"))
}

// TurnsServiceClient is a client for the pincer.protocol.v1.TurnsService service.
type TurnsServiceClient interface {
	SendTurn(context.Context, *connect.Request[v1.SendTurnRequest]) (*connect.Response[v1.SendTurnResponse], error)
	StartTurn(context.Context, *connect.Request[v1.StartTurnRequest]) (*connect.ServerStreamForClient[v1.ThreadEvent], error)
}

// NewTurnsServiceClient constructs a client for the pincer.protocol.v1.TurnsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTurnsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) TurnsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	turnsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("TurnsService").Methods()
	return &turnsServiceClient{
		sendTurn: connect.NewClient[v1.SendTurnRequest, v1.SendTurnResponse](
			httpClient,
			baseURL+TurnsServiceSendTurnProcedure,
			connect.WithSchema(turnsServiceMethods.ByName("SendTurn")),
			connect.WithClientOptions(opts...),
		),
		startTurn: connect.NewClient[v1.StartTurnRequest, v1.ThreadEvent](
			httpClient,
			baseURL+TurnsServiceStartTurnProcedure,
			connect.WithSchema(turnsServiceMethods.ByName("StartTurn")),
			connect.WithClientOptions(opts...),
		),
	}
}

// turnsServiceClient implements TurnsServiceClient.
type turnsServiceClient struct {
	sendTurn  *connect.Client[v1.SendTurnRequest, v1.SendTurnResponse]
	startTurn *connect.Client[v1.StartTurnRequest, v1.ThreadEvent]
}

// SendTurn calls pincer.protocol.v1.TurnsService.SendTurn.
func (c *turnsServiceClient) SendTurn(ctx context.Context, req *connect.Request[v1.SendTurnRequest]) (*connect.Response[v1.SendTurnResponse], error) {
	return c.sendTurn.CallUnary(ctx, req)
}

// StartTurn calls pincer.protocol.v1.TurnsService.StartTurn.
func (c *turnsServiceClient) StartTurn(ctx context.Context, req *connect.Request[v1.StartTurnRequest]) (*connect.ServerStreamForClient[v1.ThreadEvent], error) {
	return c.startTurn.CallServerStream(ctx, req)
}

// TurnsServiceHandler is an implementation of the pincer.protocol.v1.TurnsService service.
type TurnsServiceHandler interface {
	SendTurn(context.Context, *connect.Request[v1.SendTurnRequest]) (*connect.Response[v1.SendTurnResponse], error)
	StartTurn(context.Context, *connect.Request[v1.StartTurnRequest], *connect.ServerStream[v1.ThreadEvent]) error
}

// NewTurnsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTurnsServiceHandler(svc TurnsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	turnsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("TurnsService").Methods()
	turnsServiceSendTurnHandler := connect.NewUnaryHandler(
		TurnsServiceSendTurnProcedure,
		svc.SendTurn,
		connect.WithSchema(turnsServiceMethods.ByName("SendTurn")),
		connect.WithHandlerOptions(opts...),
	)
	turnsServiceStartTurnHandler := connect.NewServerStreamHandler(
		TurnsServiceStartTurnProcedure,
		svc.StartTurn,
		connect.WithSchema(turnsServiceMethods.ByName("StartTurn")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.TurnsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case TurnsServiceSendTurnProcedure:
			turnsServiceSendTurnHandler.ServeHTTP(w, r)
		case TurnsServiceStartTurnProcedure:
			turnsServiceStartTurnHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedTurnsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTurnsServiceHandler struct{}

func (UnimplementedTurnsServiceHandler) SendTurn(context.Context, *connect.Request[v1.SendTurnRequest]) (*connect.Response[v1.SendTurnResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.TurnsService.SendTurn is not implemented"))
}

func (UnimplementedTurnsServiceHandler) StartTurn(context.Context, *connect.Request[v1.StartTurnRequest], *connect.ServerStream[v1.ThreadEvent]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.TurnsService.StartTurn is not implemented"))
}

// EventsServiceClient is a client for the pincer.protocol.v1.EventsService service.
type EventsServiceClient interface {
	WatchThread(context.Context, *connect.Request[v1.WatchThreadRequest]) (*connect.ServerStreamForClient[v1.ThreadEvent], error)
}

// NewEventsServiceClient constructs a client for the pincer.protocol.v1.EventsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEventsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) EventsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	eventsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("EventsService").Methods()
	return &eventsServiceClient{
		watchThread: connect.NewClient[v1.WatchThreadRequest, v1.ThreadEvent](
			httpClient,
			baseURL+EventsServiceWatchThreadProcedure,
			connect.WithSchema(eventsServiceMethods.ByName("WatchThread")),
			connect.WithClientOptions(opts...),
		),
	}
}

// eventsServiceClient implements EventsServiceClient.
type eventsServiceClient struct {
	watchThread *connect.Client[v1.WatchThreadRequest, v1.ThreadEvent]
}

// WatchThread calls pincer.protocol.v1.EventsService.WatchThread.
func (c *eventsServiceClient) WatchThread(ctx context.Context, req *connect.Request[v1.WatchThreadRequest]) (*connect.ServerStreamForClient[v1.ThreadEvent], error) {
	return c.watchThread.CallServerStream(ctx, req)
}

// EventsServiceHandler is an implementation of the pincer.protocol.v1.EventsService service.
type EventsServiceHandler interface {
	WatchThread(context.Context, *connect.Request[v1.WatchThreadRequest], *connect.ServerStream[v1.ThreadEvent]) error
}

// NewEventsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEventsServiceHandler(svc EventsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	eventsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("EventsService").Methods()
	eventsServiceWatchThreadHandler := connect.NewServerStreamHandler(
		EventsServiceWatchThreadProcedure,
		svc.WatchThread,
		connect.WithSchema(eventsServiceMethods.ByName("WatchThread")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.EventsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case EventsServiceWatchThreadProcedure:
			eventsServiceWatchThreadHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedEventsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEventsServiceHandler struct{}

func (UnimplementedEventsServiceHandler) WatchThread(context.Context, *connect.Request[v1.WatchThreadRequest], *connect.ServerStream[v1.ThreadEvent]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.EventsService.WatchThread is not implemented"))
}

// ApprovalsServiceClient is a client for the pincer.protocol.v1.ApprovalsService service.
type ApprovalsServiceClient interface {
	ListApprovals(context.Context, *connect.Request[v1.ListApprovalsRequest]) (*connect.Response[v1.ListApprovalsResponse], error)
	ApproveAction(context.Context, *connect.Request[v1.ApproveActionRequest]) (*connect.Response[v1.ApproveActionResponse], error)
	RejectAction(context.Context, *connect.Request[v1.RejectActionRequest]) (*connect.Response[v1.RejectActionResponse], error)
}

// NewApprovalsServiceClient constructs a client for the pincer.protocol.v1.ApprovalsService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewApprovalsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ApprovalsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	approvalsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("ApprovalsService").Methods()
	return &approvalsServiceClient{
		listApprovals: connect.NewClient[v1.ListApprovalsRequest, v1.ListApprovalsResponse](
			httpClient,
			baseURL+ApprovalsServiceListApprovalsProcedure,
			connect.WithSchema(approvalsServiceMethods.ByName("ListApprovals")),
			connect.WithClientOptions(opts...),
		),
		approveAction: connect.NewClient[v1.ApproveActionRequest, v1.ApproveActionResponse](
			httpClient,
			baseURL+ApprovalsServiceApproveActionProcedure,
			connect.WithSchema(approvalsServiceMethods.ByName("ApproveAction")),
			connect.WithClientOptions(opts...),
		),
		rejectAction: connect.NewClient[v1.RejectActionRequest, v1.RejectActionResponse](
			httpClient,
			baseURL+ApprovalsServiceRejectActionProcedure,
			connect.WithSchema(approvalsServiceMethods.ByName("RejectAction")),
			connect.WithClientOptions(opts...),
		),
	}
}

// approvalsServiceClient implements ApprovalsServiceClient.
type approvalsServiceClient struct {
	listApprovals *connect.Client[v1.ListApprovalsRequest, v1.ListApprovalsResponse]
	approveAction *connect.Client[v1.ApproveActionRequest, v1.ApproveActionResponse]
	rejectAction  *connect.Client[v1.RejectActionRequest, v1.RejectActionResponse]
}

// ListApprovals calls pincer.protocol.v1.ApprovalsService.ListApprovals.
func (c *approvalsServiceClient) ListApprovals(ctx context.Context, req *connect.Request[v1.ListApprovalsRequest]) (*connect.Response[v1.ListApprovalsResponse], error) {
	return c.listApprovals.CallUnary(ctx, req)
}

// ApproveAction calls pincer.protocol.v1.ApprovalsService.ApproveAction.
func (c *approvalsServiceClient) ApproveAction(ctx context.Context, req *connect.Request[v1.ApproveActionRequest]) (*connect.Response[v1.ApproveActionResponse], error) {
	return c.approveAction.CallUnary(ctx, req)
}

// RejectAction calls pincer.protocol.v1.ApprovalsService.RejectAction.
func (c *approvalsServiceClient) RejectAction(ctx context.Context, req *connect.Request[v1.RejectActionRequest]) (*connect.Response[v1.RejectActionResponse], error) {
	return c.rejectAction.CallUnary(ctx, req)
}

// ApprovalsServiceHandler is an implementation of the pincer.protocol.v1.ApprovalsService service.
type ApprovalsServiceHandler interface {
	ListApprovals(context.Context, *connect.Request[v1.ListApprovalsRequest]) (*connect.Response[v1.ListApprovalsResponse], error)
	ApproveAction(context.Context, *connect.Request[v1.ApproveActionRequest]) (*connect.Response[v1.ApproveActionResponse], error)
	RejectAction(context.Context, *connect.Request[v1.RejectActionRequest]) (*connect.Response[v1.RejectActionResponse], error)
}

// NewApprovalsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewApprovalsServiceHandler(svc ApprovalsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	approvalsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("ApprovalsService").Methods()
	approvalsServiceListApprovalsHandler := connect.NewUnaryHandler(
		ApprovalsServiceListApprovalsProcedure,
		svc.ListApprovals,
		connect.WithSchema(approvalsServiceMethods.ByName("ListApprovals")),
		connect.WithHandlerOptions(opts...),
	)
	approvalsServiceApproveActionHandler := connect.NewUnaryHandler(
		ApprovalsServiceApproveActionProcedure,
		svc.ApproveAction,
		connect.WithSchema(approvalsServiceMethods.ByName("ApproveAction")),
		connect.WithHandlerOptions(opts...),
	)
	approvalsServiceRejectActionHandler := connect.NewUnaryHandler(
		ApprovalsServiceRejectActionProcedure,
		svc.RejectAction,
		connect.WithSchema(approvalsServiceMethods.ByName("RejectAction")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.ApprovalsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ApprovalsServiceListApprovalsProcedure:
			approvalsServiceListApprovalsHandler.ServeHTTP(w, r)
		case ApprovalsServiceApproveActionProcedure:
			approvalsServiceApproveActionHandler.ServeHTTP(w, r)
		case ApprovalsServiceRejectActionProcedure:
			approvalsServiceRejectActionHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedApprovalsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedApprovalsServiceHandler struct{}

func (UnimplementedApprovalsServiceHandler) ListApprovals(context.Context, *connect.Request[v1.ListApprovalsRequest]) (*connect.Response[v1.ListApprovalsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ApprovalsService.ListApprovals is not implemented"))
}

func (UnimplementedApprovalsServiceHandler) ApproveAction(context.Context, *connect.Request[v1.ApproveActionRequest]) (*connect.Response[v1.ApproveActionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ApprovalsService.ApproveAction is not implemented"))
}

func (UnimplementedApprovalsServiceHandler) RejectAction(context.Context, *connect.Request[v1.RejectActionRequest]) (*connect.Response[v1.RejectActionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.ApprovalsService.RejectAction is not implemented"))
}

// JobsServiceClient is a client for the pincer.protocol.v1.JobsService service.
type JobsServiceClient interface {
	ListJobs(context.Context, *connect.Request[v1.ListJobsRequest]) (*connect.Response[v1.ListJobsResponse], error)
	CreateJob(context.Context, *connect.Request[v1.CreateJobRequest]) (*connect.Response[v1.CreateJobResponse], error)
	GetJob(context.Context, *connect.Request[v1.GetJobRequest]) (*connect.Response[v1.GetJobResponse], error)
	CancelJob(context.Context, *connect.Request[v1.CancelJobRequest]) (*connect.Response[v1.CancelJobResponse], error)
}

// NewJobsServiceClient constructs a client for the pincer.protocol.v1.JobsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewJobsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) JobsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	jobsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("JobsService").Methods()
	return &jobsServiceClient{
		listJobs: connect.NewClient[v1.ListJobsRequest, v1.ListJobsResponse](
			httpClient,
			baseURL+JobsServiceListJobsProcedure,
			connect.WithSchema(jobsServiceMethods.ByName("ListJobs")),
			connect.WithClientOptions(opts...),
		),
		createJob: connect.NewClient[v1.CreateJobRequest, v1.CreateJobResponse](
			httpClient,
			baseURL+JobsServiceCreateJobProcedure,
			connect.WithSchema(jobsServiceMethods.ByName("CreateJob")),
			connect.WithClientOptions(opts...),
		),
		getJob: connect.NewClient[v1.GetJobRequest, v1.GetJobResponse](
			httpClient,
			baseURL+JobsServiceGetJobProcedure,
			connect.WithSchema(jobsServiceMethods.ByName("GetJob")),
			connect.WithClientOptions(opts...),
		),
		cancelJob: connect.NewClient[v1.CancelJobRequest, v1.CancelJobResponse](
			httpClient,
			baseURL+JobsServiceCancelJobProcedure,
			connect.WithSchema(jobsServiceMethods.ByName("CancelJob")),
			connect.WithClientOptions(opts...),
		),
	}
}

// jobsServiceClient implements JobsServiceClient.
type jobsServiceClient struct {
	listJobs  *connect.Client[v1.ListJobsRequest, v1.ListJobsResponse]
	createJob *connect.Client[v1.CreateJobRequest, v1.CreateJobResponse]
	getJob    *connect.Client[v1.GetJobRequest, v1.GetJobResponse]
	cancelJob *connect.Client[v1.CancelJobRequest, v1.CancelJobResponse]
}

// ListJobs calls pincer.protocol.v1.JobsService.ListJobs.
func (c *jobsServiceClient) ListJobs(ctx context.Context, req *connect.Request[v1.ListJobsRequest]) (*connect.Response[v1.ListJobsResponse], error) {
	return c.listJobs.CallUnary(ctx, req)
}

// CreateJob calls pincer.protocol.v1.JobsService.CreateJob.
func (c *jobsServiceClient) CreateJob(ctx context.Context, req *connect.Request[v1.CreateJobRequest]) (*connect.Response[v1.CreateJobResponse], error) {
	return c.createJob.CallUnary(ctx, req)
}

// GetJob calls pincer.protocol.v1.JobsService.GetJob.
func (c *jobsServiceClient) GetJob(ctx context.Context, req *connect.Request[v1.GetJobRequest]) (*connect.Response[v1.GetJobResponse], error) {
	return c.getJob.CallUnary(ctx, req)
}

// CancelJob calls pincer.protocol.v1.JobsService.CancelJob.
func (c *jobsServiceClient) CancelJob(ctx context.Context, req *connect.Request[v1.CancelJobRequest]) (*connect.Response[v1.CancelJobResponse], error) {
	return c.cancelJob.CallUnary(ctx, req)
}

// JobsServiceHandler is an implementation of the pincer.protocol.v1.JobsService service.
type JobsServiceHandler interface {
	ListJobs(context.Context, *connect.Request[v1.ListJobsRequest]) (*connect.Response[v1.ListJobsResponse], error)
	CreateJob(context.Context, *connect.Request[v1.CreateJobRequest]) (*connect.Response[v1.CreateJobResponse], error)
	GetJob(context.Context, *connect.Request[v1.GetJobRequest]) (*connect.Response[v1.GetJobResponse], error)
	CancelJob(context.Context, *connect.Request[v1.CancelJobRequest]) (*connect.Response[v1.CancelJobResponse], error)
}

// NewJobsServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewJobsServiceHandler(svc JobsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	jobsServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("JobsService").Methods()
	jobsServiceListJobsHandler := connect.NewUnaryHandler(
		JobsServiceListJobsProcedure,
		svc.ListJobs,
		connect.WithSchema(jobsServiceMethods.ByName("ListJobs")),
		connect.WithHandlerOptions(opts...),
	)
	jobsServiceCreateJobHandler := connect.NewUnaryHandler(
		JobsServiceCreateJobProcedure,
		svc.CreateJob,
		connect.WithSchema(jobsServiceMethods.ByName("CreateJob")),
		connect.WithHandlerOptions(opts...),
	)
	jobsServiceGetJobHandler := connect.NewUnaryHandler(
		JobsServiceGetJobProcedure,
		svc.GetJob,
		connect.WithSchema(jobsServiceMethods.ByName("GetJob")),
		connect.WithHandlerOptions(opts...),
	)
	jobsServiceCancelJobHandler := connect.NewUnaryHandler(
		JobsServiceCancelJobProcedure,
		svc.CancelJob,
		connect.WithSchema(jobsServiceMethods.ByName("CancelJob")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.JobsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case JobsServiceListJobsProcedure:
			jobsServiceListJobsHandler.ServeHTTP(w, r)
		case JobsServiceCreateJobProcedure:
			jobsServiceCreateJobHandler.ServeHTTP(w, r)
		case JobsServiceGetJobProcedure:
			jobsServiceGetJobHandler.ServeHTTP(w, r)
		case JobsServiceCancelJobProcedure:
			jobsServiceCancelJobHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedJobsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedJobsServiceHandler struct{}

func (UnimplementedJobsServiceHandler) ListJobs(context.Context, *connect.Request[v1.ListJobsRequest]) (*connect.Response[v1.ListJobsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.JobsService.ListJobs is not implemented"))
}

func (UnimplementedJobsServiceHandler) CreateJob(context.Context, *connect.Request[v1.CreateJobRequest]) (*connect.Response[v1.CreateJobResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.JobsService.CreateJob is not implemented"))
}

func (UnimplementedJobsServiceHandler) GetJob(context.Context, *connect.Request[v1.GetJobRequest]) (*connect.Response[v1.GetJobResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.JobsService.GetJob is not implemented"))
}

func (UnimplementedJobsServiceHandler) CancelJob(context.Context, *connect.Request[v1.CancelJobRequest]) (*connect.Response[v1.CancelJobResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.JobsService.CancelJob is not implemented"))
}

// SchedulesServiceClient is a client for the pincer.protocol.v1.SchedulesService service.
type SchedulesServiceClient interface {
	ListSchedules(context.Context, *connect.Request[v1.ListSchedulesRequest]) (*connect.Response[v1.ListSchedulesResponse], error)
	CreateSchedule(context.Context, *connect.Request[v1.CreateScheduleRequest]) (*connect.Response[v1.CreateScheduleResponse], error)
	UpdateSchedule(context.Context, *connect.Request[v1.UpdateScheduleRequest]) (*connect.Response[v1.UpdateScheduleResponse], error)
	RunScheduleNow(context.Context, *connect.Request[v1.RunScheduleNowRequest]) (*connect.Response[v1.RunScheduleNowResponse], error)
}

// NewSchedulesServiceClient constructs a client for the pincer.protocol.v1.SchedulesService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewSchedulesServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) SchedulesServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	schedulesServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("SchedulesService").Methods()
	return &schedulesServiceClient{
		listSchedules: connect.NewClient[v1.ListSchedulesRequest, v1.ListSchedulesResponse](
			httpClient,
			baseURL+SchedulesServiceListSchedulesProcedure,
			connect.WithSchema(schedulesServiceMethods.ByName("ListSchedules")),
			connect.WithClientOptions(opts...),
		),
		createSchedule: connect.NewClient[v1.CreateScheduleRequest, v1.CreateScheduleResponse](
			httpClient,
			baseURL+SchedulesServiceCreateScheduleProcedure,
			connect.WithSchema(schedulesServiceMethods.ByName("CreateSchedule")),
			connect.WithClientOptions(opts...),
		),
		updateSchedule: connect.NewClient[v1.UpdateScheduleRequest, v1.UpdateScheduleResponse](
			httpClient,
			baseURL+SchedulesServiceUpdateScheduleProcedure,
			connect.WithSchema(schedulesServiceMethods.ByName("UpdateSchedule")),
			connect.WithClientOptions(opts...),
		),
		runScheduleNow: connect.NewClient[v1.RunScheduleNowRequest, v1.RunScheduleNowResponse](
			httpClient,
			baseURL+SchedulesServiceRunScheduleNowProcedure,
			connect.WithSchema(schedulesServiceMethods.ByName("RunScheduleNow")),
			connect.WithClientOptions(opts...),
		),
	}
}

// schedulesServiceClient implements SchedulesServiceClient.
type schedulesServiceClient struct {
	listSchedules  *connect.Client[v1.ListSchedulesRequest, v1.ListSchedulesResponse]
	createSchedule *connect.Client[v1.CreateScheduleRequest, v1.CreateScheduleResponse]
	updateSchedule *connect.Client[v1.UpdateScheduleRequest, v1.UpdateScheduleResponse]
	runScheduleNow *connect.Client[v1.RunScheduleNowRequest, v1.RunScheduleNowResponse]
}

// ListSchedules calls pincer.protocol.v1.SchedulesService.ListSchedules.
func (c *schedulesServiceClient) ListSchedules(ctx context.Context, req *connect.Request[v1.ListSchedulesRequest]) (*connect.Response[v1.ListSchedulesResponse], error) {
	return c.listSchedules.CallUnary(ctx, req)
}

// CreateSchedule calls pincer.protocol.v1.SchedulesService.CreateSchedule.
func (c *schedulesServiceClient) CreateSchedule(ctx context.Context, req *connect.Request[v1.CreateScheduleRequest]) (*connect.Response[v1.CreateScheduleResponse], error) {
	return c.createSchedule.CallUnary(ctx, req)
}

// UpdateSchedule calls pincer.protocol.v1.SchedulesService.UpdateSchedule.
func (c *schedulesServiceClient) UpdateSchedule(ctx context.Context, req *connect.Request[v1.UpdateScheduleRequest]) (*connect.Response[v1.UpdateScheduleResponse], error) {
	return c.updateSchedule.CallUnary(ctx, req)
}

// RunScheduleNow calls pincer.protocol.v1.SchedulesService.RunScheduleNow.
func (c *schedulesServiceClient) RunScheduleNow(ctx context.Context, req *connect.Request[v1.RunScheduleNowRequest]) (*connect.Response[v1.RunScheduleNowResponse], error) {
	return c.runScheduleNow.CallUnary(ctx, req)
}

// SchedulesServiceHandler is an implementation of the pincer.protocol.v1.SchedulesService service.
type SchedulesServiceHandler interface {
	ListSchedules(context.Context, *connect.Request[v1.ListSchedulesRequest]) (*connect.Response[v1.ListSchedulesResponse], error)
	CreateSchedule(context.Context, *connect.Request[v1.CreateScheduleRequest]) (*connect.Response[v1.CreateScheduleResponse], error)
	UpdateSchedule(context.Context, *connect.Request[v1.UpdateScheduleRequest]) (*connect.Response[v1.UpdateScheduleResponse], error)
	RunScheduleNow(context.Context, *connect.Request[v1.RunScheduleNowRequest]) (*connect.Response[v1.RunScheduleNowResponse], error)
}

// NewSchedulesServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewSchedulesServiceHandler(svc SchedulesServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	schedulesServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("SchedulesService").Methods()
	schedulesServiceListSchedulesHandler := connect.NewUnaryHandler(
		SchedulesServiceListSchedulesProcedure,
		svc.ListSchedules,
		connect.WithSchema(schedulesServiceMethods.ByName("ListSchedules")),
		connect.WithHandlerOptions(opts...),
	)
	schedulesServiceCreateScheduleHandler := connect.NewUnaryHandler(
		SchedulesServiceCreateScheduleProcedure,
		svc.CreateSchedule,
		connect.WithSchema(schedulesServiceMethods.ByName("CreateSchedule")),
		connect.WithHandlerOptions(opts...),
	)
	schedulesServiceUpdateScheduleHandler := connect.NewUnaryHandler(
		SchedulesServiceUpdateScheduleProcedure,
		svc.UpdateSchedule,
		connect.WithSchema(schedulesServiceMethods.ByName("UpdateSchedule")),
		connect.WithHandlerOptions(opts...),
	)
	schedulesServiceRunScheduleNowHandler := connect.NewUnaryHandler(
		SchedulesServiceRunScheduleNowProcedure,
		svc.RunScheduleNow,
		connect.WithSchema(schedulesServiceMethods.ByName("RunScheduleNow")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.SchedulesService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case SchedulesServiceListSchedulesProcedure:
			schedulesServiceListSchedulesHandler.ServeHTTP(w, r)
		case SchedulesServiceCreateScheduleProcedure:
			schedulesServiceCreateScheduleHandler.ServeHTTP(w, r)
		case SchedulesServiceUpdateScheduleProcedure:
			schedulesServiceUpdateScheduleHandler.ServeHTTP(w, r)
		case SchedulesServiceRunScheduleNowProcedure:
			schedulesServiceRunScheduleNowHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedSchedulesServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedSchedulesServiceHandler struct{}

func (UnimplementedSchedulesServiceHandler) ListSchedules(context.Context, *connect.Request[v1.ListSchedulesRequest]) (*connect.Response[v1.ListSchedulesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SchedulesService.ListSchedules is not implemented"))
}

func (UnimplementedSchedulesServiceHandler) CreateSchedule(context.Context, *connect.Request[v1.CreateScheduleRequest]) (*connect.Response[v1.CreateScheduleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SchedulesService.CreateSchedule is not implemented"))
}

func (UnimplementedSchedulesServiceHandler) UpdateSchedule(context.Context, *connect.Request[v1.UpdateScheduleRequest]) (*connect.Response[v1.UpdateScheduleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SchedulesService.UpdateSchedule is not implemented"))
}

func (UnimplementedSchedulesServiceHandler) RunScheduleNow(context.Context, *connect.Request[v1.RunScheduleNowRequest]) (*connect.Response[v1.RunScheduleNowResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SchedulesService.RunScheduleNow is not implemented"))
}

// SystemServiceClient is a client for the pincer.protocol.v1.SystemService service.
type SystemServiceClient interface {
	GetPolicySummary(context.Context, *connect.Request[v1.GetPolicySummaryRequest]) (*connect.Response[v1.GetPolicySummaryResponse], error)
	ListAudit(context.Context, *connect.Request[v1.ListAuditRequest]) (*connect.Response[v1.ListAuditResponse], error)
	ListNotifications(context.Context, *connect.Request[v1.ListNotificationsRequest]) (*connect.Response[v1.ListNotificationsResponse], error)
}

// NewSystemServiceClient constructs a client for the pincer.protocol.v1.SystemService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewSystemServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) SystemServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	systemServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("SystemService").Methods()
	return &systemServiceClient{
		getPolicySummary: connect.NewClient[v1.GetPolicySummaryRequest, v1.GetPolicySummaryResponse](
			httpClient,
			baseURL+SystemServiceGetPolicySummaryProcedure,
			connect.WithSchema(systemServiceMethods.ByName("GetPolicySummary")),
			connect.WithClientOptions(opts...),
		),
		listAudit: connect.NewClient[v1.ListAuditRequest, v1.ListAuditResponse](
			httpClient,
			baseURL+SystemServiceListAuditProcedure,
			connect.WithSchema(systemServiceMethods.ByName("ListAudit")),
			connect.WithClientOptions(opts...),
		),
		listNotifications: connect.NewClient[v1.ListNotificationsRequest, v1.ListNotificationsResponse](
			httpClient,
			baseURL+SystemServiceListNotificationsProcedure,
			connect.WithSchema(systemServiceMethods.ByName("ListNotifications")),
			connect.WithClientOptions(opts...),
		),
	}
}

// systemServiceClient implements SystemServiceClient.
type systemServiceClient struct {
	getPolicySummary  *connect.Client[v1.GetPolicySummaryRequest, v1.GetPolicySummaryResponse]
	listAudit         *connect.Client[v1.ListAuditRequest, v1.ListAuditResponse]
	listNotifications *connect.Client[v1.ListNotificationsRequest, v1.ListNotificationsResponse]
}

// GetPolicySummary calls pincer.protocol.v1.SystemService.GetPolicySummary.
func (c *systemServiceClient) GetPolicySummary(ctx context.Context, req *connect.Request[v1.GetPolicySummaryRequest]) (*connect.Response[v1.GetPolicySummaryResponse], error) {
	return c.getPolicySummary.CallUnary(ctx, req)
}

// ListAudit calls pincer.protocol.v1.SystemService.ListAudit.
func (c *systemServiceClient) ListAudit(ctx context.Context, req *connect.Request[v1.ListAuditRequest]) (*connect.Response[v1.ListAuditResponse], error) {
	return c.listAudit.CallUnary(ctx, req)
}

// ListNotifications calls pincer.protocol.v1.SystemService.ListNotifications.
func (c *systemServiceClient) ListNotifications(ctx context.Context, req *connect.Request[v1.ListNotificationsRequest]) (*connect.Response[v1.ListNotificationsResponse], error) {
	return c.listNotifications.CallUnary(ctx, req)
}

// SystemServiceHandler is an implementation of the pincer.protocol.v1.SystemService service.
type SystemServiceHandler interface {
	GetPolicySummary(context.Context, *connect.Request[v1.GetPolicySummaryRequest]) (*connect.Response[v1.GetPolicySummaryResponse], error)
	ListAudit(context.Context, *connect.Request[v1.ListAuditRequest]) (*connect.Response[v1.ListAuditResponse], error)
	ListNotifications(context.Context, *connect.Request[v1.ListNotificationsRequest]) (*connect.Response[v1.ListNotificationsResponse], error)
}

// NewSystemServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewSystemServiceHandler(svc SystemServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	systemServiceMethods := v1.File_proto_pincer_protocol_v1_protocol_proto.Services().ByName("SystemService").Methods()
	systemServiceGetPolicySummaryHandler := connect.NewUnaryHandler(
		SystemServiceGetPolicySummaryProcedure,
		svc.GetPolicySummary,
		connect.WithSchema(systemServiceMethods.ByName("GetPolicySummary")),
		connect.WithHandlerOptions(opts...),
	)
	systemServiceListAuditHandler := connect.NewUnaryHandler(
		SystemServiceListAuditProcedure,
		svc.ListAudit,
		connect.WithSchema(systemServiceMethods.ByName("ListAudit")),
		connect.WithHandlerOptions(opts...),
	)
	systemServiceListNotificationsHandler := connect.NewUnaryHandler(
		SystemServiceListNotificationsProcedure,
		svc.ListNotifications,
		connect.WithSchema(systemServiceMethods.ByName("ListNotifications")),
		connect.WithHandlerOptions(opts...),
	)
	return "/pincer.protocol.v1.SystemService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case SystemServiceGetPolicySummaryProcedure:
			systemServiceGetPolicySummaryHandler.ServeHTTP(w, r)
		case SystemServiceListAuditProcedure:
			systemServiceListAuditHandler.ServeHTTP(w, r)
		case SystemServiceListNotificationsProcedure:
			systemServiceListNotificationsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedSystemServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedSystemServiceHandler struct{}

func (UnimplementedSystemServiceHandler) GetPolicySummary(context.Context, *connect.Request[v1.GetPolicySummaryRequest]) (*connect.Response[v1.GetPolicySummaryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SystemService.GetPolicySummary is not implemented"))
}

func (UnimplementedSystemServiceHandler) ListAudit(context.Context, *connect.Request[v1.ListAuditRequest]) (*connect.Response[v1.ListAuditResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SystemService.ListAudit is not implemented"))
}

func (UnimplementedSystemServiceHandler) ListNotifications(context.Context, *connect.Request[v1.ListNotificationsRequest]) (*connect.Response[v1.ListNotificationsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("pincer.protocol.v1.SystemService.ListNotifications is not implemented"))
}
