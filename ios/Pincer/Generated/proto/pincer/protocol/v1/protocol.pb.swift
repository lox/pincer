// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/pincer/protocol/v1/protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Pincer_Protocol_V1_QueueMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case rejectIfBusy // = 1
  case interruptAfterCurrentTool // = 2
  case queueAfterTurn // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .rejectIfBusy
    case 2: self = .interruptAfterCurrentTool
    case 3: self = .queueAfterTurn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .rejectIfBusy: return 1
    case .interruptAfterCurrentTool: return 2
    case .queueAfterTurn: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_QueueMode] = [
    .unspecified,
    .rejectIfBusy,
    .interruptAfterCurrentTool,
    .queueAfterTurn,
  ]

}

public enum Pincer_Protocol_V1_ReasoningVisibility: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case reasoningOff // = 1
  case reasoningSummary // = 2
  case reasoningRaw // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reasoningOff
    case 2: self = .reasoningSummary
    case 3: self = .reasoningRaw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reasoningOff: return 1
    case .reasoningSummary: return 2
    case .reasoningRaw: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_ReasoningVisibility] = [
    .unspecified,
    .reasoningOff,
    .reasoningSummary,
    .reasoningRaw,
  ]

}

public enum Pincer_Protocol_V1_EventSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case modelUntrusted // = 1
  case policyEngine // = 2
  case toolExecutor // = 3
  case system // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .modelUntrusted
    case 2: self = .policyEngine
    case 3: self = .toolExecutor
    case 4: self = .system
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .modelUntrusted: return 1
    case .policyEngine: return 2
    case .toolExecutor: return 3
    case .system: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_EventSource] = [
    .unspecified,
    .modelUntrusted,
    .policyEngine,
    .toolExecutor,
    .system,
  ]

}

public enum Pincer_Protocol_V1_ContentTrust: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case untrustedModel // = 1
  case trustedValidated // = 2
  case trustedSystem // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .untrustedModel
    case 2: self = .trustedValidated
    case 3: self = .trustedSystem
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .untrustedModel: return 1
    case .trustedValidated: return 2
    case .trustedSystem: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_ContentTrust] = [
    .unspecified,
    .untrustedModel,
    .trustedValidated,
    .trustedSystem,
  ]

}

public enum Pincer_Protocol_V1_Identity: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case user // = 1
  case bot // = 2
  case none // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .user
    case 2: self = .bot
    case 3: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .user: return 1
    case .bot: return 2
    case .none: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_Identity] = [
    .unspecified,
    .user,
    .bot,
    .none,
  ]

}

public enum Pincer_Protocol_V1_RiskClass: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case read // = 1
  case write // = 2
  case exfiltration // = 3
  case destructive // = 4
  case high // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .read
    case 2: self = .write
    case 3: self = .exfiltration
    case 4: self = .destructive
    case 5: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .read: return 1
    case .write: return 2
    case .exfiltration: return 3
    case .destructive: return 4
    case .high: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_RiskClass] = [
    .unspecified,
    .read,
    .write,
    .exfiltration,
    .destructive,
    .high,
  ]

}

public enum Pincer_Protocol_V1_PolicyDecision: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case allowInternal // = 1
  case requireApproval // = 2
  case blocked // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .allowInternal
    case 2: self = .requireApproval
    case 3: self = .blocked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .allowInternal: return 1
    case .requireApproval: return 2
    case .blocked: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_PolicyDecision] = [
    .unspecified,
    .allowInternal,
    .requireApproval,
    .blocked,
  ]

}

public enum Pincer_Protocol_V1_ActionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case pending // = 1
  case approved // = 2
  case rejected // = 3
  case executed // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .approved
    case 3: self = .rejected
    case 4: self = .executed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .approved: return 2
    case .rejected: return 3
    case .executed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_ActionStatus] = [
    .unspecified,
    .pending,
    .approved,
    .rejected,
    .executed,
  ]

}

public enum Pincer_Protocol_V1_OutputStream: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case stdout // = 1
  case stderr // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .stdout
    case 2: self = .stderr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .stdout: return 1
    case .stderr: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_OutputStream] = [
    .unspecified,
    .stdout,
    .stderr,
  ]

}

public enum Pincer_Protocol_V1_TriggerType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case chatMessage // = 1
  case jobWakeup // = 2
  case scheduleWakeup // = 3
  case heartbeat // = 4
  case delegatedCallback // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .chatMessage
    case 2: self = .jobWakeup
    case 3: self = .scheduleWakeup
    case 4: self = .heartbeat
    case 5: self = .delegatedCallback
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .chatMessage: return 1
    case .jobWakeup: return 2
    case .scheduleWakeup: return 3
    case .heartbeat: return 4
    case .delegatedCallback: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_TriggerType] = [
    .unspecified,
    .chatMessage,
    .jobWakeup,
    .scheduleWakeup,
    .heartbeat,
    .delegatedCallback,
  ]

}

public enum Pincer_Protocol_V1_JobStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case jobRunning // = 1
  case jobWaitingApproval // = 2
  case jobCompleted // = 3
  case jobFailed // = 4
  case jobPausedBudget // = 5
  case jobCancelled // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .jobRunning
    case 2: self = .jobWaitingApproval
    case 3: self = .jobCompleted
    case 4: self = .jobFailed
    case 5: self = .jobPausedBudget
    case 6: self = .jobCancelled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .jobRunning: return 1
    case .jobWaitingApproval: return 2
    case .jobCompleted: return 3
    case .jobFailed: return 4
    case .jobPausedBudget: return 5
    case .jobCancelled: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_JobStatus] = [
    .unspecified,
    .jobRunning,
    .jobWaitingApproval,
    .jobCompleted,
    .jobFailed,
    .jobPausedBudget,
    .jobCancelled,
  ]

}

public enum Pincer_Protocol_V1_ScheduleTriggerKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case scheduleTriggerCron // = 1
  case scheduleTriggerInterval // = 2
  case scheduleTriggerAt // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .scheduleTriggerCron
    case 2: self = .scheduleTriggerInterval
    case 3: self = .scheduleTriggerAt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .scheduleTriggerCron: return 1
    case .scheduleTriggerInterval: return 2
    case .scheduleTriggerAt: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_ScheduleTriggerKind] = [
    .unspecified,
    .scheduleTriggerCron,
    .scheduleTriggerInterval,
    .scheduleTriggerAt,
  ]

}

public enum Pincer_Protocol_V1_NotificationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case notificationPendingApprovalCreated // = 1
  case notificationApprovalExpiringSoon // = 2
  case notificationJobCompleted // = 3
  case notificationJobFailed // = 4
  case notificationProactiveReachOut // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notificationPendingApprovalCreated
    case 2: self = .notificationApprovalExpiringSoon
    case 3: self = .notificationJobCompleted
    case 4: self = .notificationJobFailed
    case 5: self = .notificationProactiveReachOut
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notificationPendingApprovalCreated: return 1
    case .notificationApprovalExpiringSoon: return 2
    case .notificationJobCompleted: return 3
    case .notificationJobFailed: return 4
    case .notificationProactiveReachOut: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pincer_Protocol_V1_NotificationType] = [
    .unspecified,
    .notificationPendingApprovalCreated,
    .notificationApprovalExpiringSoon,
    .notificationJobCompleted,
    .notificationJobFailed,
    .notificationProactiveReachOut,
  ]

}

public struct Pincer_Protocol_V1_CreatePairingCodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreatePairingCodeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_BindPairingCodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var deviceName: String = String()

  public var publicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_BindPairingCodeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceID: String = String()

  public var token: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var renewAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_renewAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_renewAfter = newValue}
  }
  /// Returns true if `renewAfter` has been explicitly set.
  public var hasRenewAfter: Bool {self._renewAfter != nil}
  /// Clears the value of `renewAfter`. Subsequent reads from it will return its default value.
  public mutating func clearRenewAfter() {self._renewAfter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _renewAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_RotateTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RotateTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var renewAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_renewAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_renewAfter = newValue}
  }
  /// Returns true if `renewAfter` has been explicitly set.
  public var hasRenewAfter: Bool {self._renewAfter != nil}
  /// Clears the value of `renewAfter`. Subsequent reads from it will return its default value.
  public mutating func clearRenewAfter() {self._renewAfter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _renewAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_Device: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceID: String = String()

  public var name: String = String()

  public var isCurrent: Bool = false

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_revokedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_revokedAt = newValue}
  }
  /// Returns true if `revokedAt` has been explicitly set.
  public var hasRevokedAt: Bool {self._revokedAt != nil}
  /// Clears the value of `revokedAt`. Subsequent reads from it will return its default value.
  public mutating func clearRevokedAt() {self._revokedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _revokedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_Device] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RevokeDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RevokeDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreateThreadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreateThreadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var lastSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_TurnBudget: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxToolSteps: UInt32 = 0

  public var maxToolTokens: UInt32 = 0

  public var maxContextMessages: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_StartTurnRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var clientMessageID: String = String()

  public var userText: String = String()

  public var queueMode: Pincer_Protocol_V1_QueueMode = .unspecified

  public var reasoningVisibility: Pincer_Protocol_V1_ReasoningVisibility = .unspecified

  public var triggerType: Pincer_Protocol_V1_TriggerType = .unspecified

  public var triggerSourceID: String = String()

  public var requestedBudget: Pincer_Protocol_V1_TurnBudget {
    get {_requestedBudget ?? Pincer_Protocol_V1_TurnBudget()}
    set {_requestedBudget = newValue}
  }
  /// Returns true if `requestedBudget` has been explicitly set.
  public var hasRequestedBudget: Bool {self._requestedBudget != nil}
  /// Clears the value of `requestedBudget`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedBudget() {self._requestedBudget = nil}

  public var resumeFromSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestedBudget: Pincer_Protocol_V1_TurnBudget? = nil
}

public struct Pincer_Protocol_V1_SendTurnRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var userText: String = String()

  public var triggerType: Pincer_Protocol_V1_TriggerType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_SendTurnResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var turnID: String = String()

  public var assistantMessage: String = String()

  public var actionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_WatchThreadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var fromSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_GetThreadSnapshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListThreadMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var pageSize: UInt32 = 0

  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ThreadMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var role: String = String()

  public var content: String = String()

  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {_metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var contentTrust: Pincer_Protocol_V1_ContentTrust = .unspecified

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_GetThreadSnapshotResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var threadID: String = String()

  public var lastSequence: UInt64 = 0

  public var messages: [Pincer_Protocol_V1_ThreadMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListThreadMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_ThreadMessage] = []

  public var nextPageToken: String = String()

  public var lastSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ThreadEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String {
    get {_storage._eventID}
    set {_uniqueStorage()._eventID = newValue}
  }

  public var threadID: String {
    get {_storage._threadID}
    set {_uniqueStorage()._threadID = newValue}
  }

  public var jobID: String {
    get {_storage._jobID}
    set {_uniqueStorage()._jobID = newValue}
  }

  public var turnID: String {
    get {_storage._turnID}
    set {_uniqueStorage()._turnID = newValue}
  }

  public var sequence: UInt64 {
    get {_storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  public var occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._occurredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._occurredAt = newValue}
  }
  /// Returns true if `occurredAt` has been explicitly set.
  public var hasOccurredAt: Bool {_storage._occurredAt != nil}
  /// Clears the value of `occurredAt`. Subsequent reads from it will return its default value.
  public mutating func clearOccurredAt() {_uniqueStorage()._occurredAt = nil}

  public var source: Pincer_Protocol_V1_EventSource {
    get {_storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  public var contentTrust: Pincer_Protocol_V1_ContentTrust {
    get {_storage._contentTrust}
    set {_uniqueStorage()._contentTrust = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var turnStarted: Pincer_Protocol_V1_TurnStarted {
    get {
      if case .turnStarted(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_TurnStarted()
    }
    set {_uniqueStorage()._payload = .turnStarted(newValue)}
  }

  public var turnBudgetApplied: Pincer_Protocol_V1_TurnBudgetApplied {
    get {
      if case .turnBudgetApplied(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_TurnBudgetApplied()
    }
    set {_uniqueStorage()._payload = .turnBudgetApplied(newValue)}
  }

  public var modelOutputRepairAttempted: Pincer_Protocol_V1_ModelOutputRepairAttempted {
    get {
      if case .modelOutputRepairAttempted(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ModelOutputRepairAttempted()
    }
    set {_uniqueStorage()._payload = .modelOutputRepairAttempted(newValue)}
  }

  public var turnCompleted: Pincer_Protocol_V1_TurnCompleted {
    get {
      if case .turnCompleted(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_TurnCompleted()
    }
    set {_uniqueStorage()._payload = .turnCompleted(newValue)}
  }

  public var turnFailed: Pincer_Protocol_V1_TurnFailed {
    get {
      if case .turnFailed(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_TurnFailed()
    }
    set {_uniqueStorage()._payload = .turnFailed(newValue)}
  }

  public var assistantThinkingDelta: Pincer_Protocol_V1_AssistantThinkingDelta {
    get {
      if case .assistantThinkingDelta(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_AssistantThinkingDelta()
    }
    set {_uniqueStorage()._payload = .assistantThinkingDelta(newValue)}
  }

  public var assistantTextDelta: Pincer_Protocol_V1_AssistantTextDelta {
    get {
      if case .assistantTextDelta(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_AssistantTextDelta()
    }
    set {_uniqueStorage()._payload = .assistantTextDelta(newValue)}
  }

  public var assistantMessageCommitted: Pincer_Protocol_V1_AssistantMessageCommitted {
    get {
      if case .assistantMessageCommitted(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_AssistantMessageCommitted()
    }
    set {_uniqueStorage()._payload = .assistantMessageCommitted(newValue)}
  }

  public var toolCallPlanned: Pincer_Protocol_V1_ToolCallPlanned {
    get {
      if case .toolCallPlanned(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ToolCallPlanned()
    }
    set {_uniqueStorage()._payload = .toolCallPlanned(newValue)}
  }

  public var toolExecutionStarted: Pincer_Protocol_V1_ToolExecutionStarted {
    get {
      if case .toolExecutionStarted(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ToolExecutionStarted()
    }
    set {_uniqueStorage()._payload = .toolExecutionStarted(newValue)}
  }

  public var toolExecutionOutputDelta: Pincer_Protocol_V1_ToolExecutionOutputDelta {
    get {
      if case .toolExecutionOutputDelta(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ToolExecutionOutputDelta()
    }
    set {_uniqueStorage()._payload = .toolExecutionOutputDelta(newValue)}
  }

  public var toolExecutionFinished: Pincer_Protocol_V1_ToolExecutionFinished {
    get {
      if case .toolExecutionFinished(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ToolExecutionFinished()
    }
    set {_uniqueStorage()._payload = .toolExecutionFinished(newValue)}
  }

  public var policyDecisionMade: Pincer_Protocol_V1_PolicyDecisionMade {
    get {
      if case .policyDecisionMade(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_PolicyDecisionMade()
    }
    set {_uniqueStorage()._payload = .policyDecisionMade(newValue)}
  }

  public var proposedActionCreated: Pincer_Protocol_V1_ProposedActionCreated {
    get {
      if case .proposedActionCreated(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ProposedActionCreated()
    }
    set {_uniqueStorage()._payload = .proposedActionCreated(newValue)}
  }

  public var proposedActionStatusChanged: Pincer_Protocol_V1_ProposedActionStatusChanged {
    get {
      if case .proposedActionStatusChanged(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ProposedActionStatusChanged()
    }
    set {_uniqueStorage()._payload = .proposedActionStatusChanged(newValue)}
  }

  public var idempotencyConflict: Pincer_Protocol_V1_IdempotencyConflict {
    get {
      if case .idempotencyConflict(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_IdempotencyConflict()
    }
    set {_uniqueStorage()._payload = .idempotencyConflict(newValue)}
  }

  public var jobStatusChanged: Pincer_Protocol_V1_JobStatusChanged {
    get {
      if case .jobStatusChanged(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_JobStatusChanged()
    }
    set {_uniqueStorage()._payload = .jobStatusChanged(newValue)}
  }

  public var scheduleTriggered: Pincer_Protocol_V1_ScheduleTriggered {
    get {
      if case .scheduleTriggered(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ScheduleTriggered()
    }
    set {_uniqueStorage()._payload = .scheduleTriggered(newValue)}
  }

  public var delegatedCallbackReceived: Pincer_Protocol_V1_DelegatedCallbackReceived {
    get {
      if case .delegatedCallbackReceived(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_DelegatedCallbackReceived()
    }
    set {_uniqueStorage()._payload = .delegatedCallbackReceived(newValue)}
  }

  public var auditEventRecorded: Pincer_Protocol_V1_AuditEventRecorded {
    get {
      if case .auditEventRecorded(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_AuditEventRecorded()
    }
    set {_uniqueStorage()._payload = .auditEventRecorded(newValue)}
  }

  public var notificationQueued: Pincer_Protocol_V1_NotificationQueued {
    get {
      if case .notificationQueued(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_NotificationQueued()
    }
    set {_uniqueStorage()._payload = .notificationQueued(newValue)}
  }

  public var artifactCreated: Pincer_Protocol_V1_ArtifactCreated {
    get {
      if case .artifactCreated(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_ArtifactCreated()
    }
    set {_uniqueStorage()._payload = .artifactCreated(newValue)}
  }

  public var memoryCheckpointSaved: Pincer_Protocol_V1_MemoryCheckpointSaved {
    get {
      if case .memoryCheckpointSaved(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_MemoryCheckpointSaved()
    }
    set {_uniqueStorage()._payload = .memoryCheckpointSaved(newValue)}
  }

  public var skillProposalCreated: Pincer_Protocol_V1_SkillProposalCreated {
    get {
      if case .skillProposalCreated(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_SkillProposalCreated()
    }
    set {_uniqueStorage()._payload = .skillProposalCreated(newValue)}
  }

  public var selfImprovementProposalCreated: Pincer_Protocol_V1_SelfImprovementProposalCreated {
    get {
      if case .selfImprovementProposalCreated(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_SelfImprovementProposalCreated()
    }
    set {_uniqueStorage()._payload = .selfImprovementProposalCreated(newValue)}
  }

  public var heartbeat: Pincer_Protocol_V1_Heartbeat {
    get {
      if case .heartbeat(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_Heartbeat()
    }
    set {_uniqueStorage()._payload = .heartbeat(newValue)}
  }

  public var streamGap: Pincer_Protocol_V1_StreamGap {
    get {
      if case .streamGap(let v)? = _storage._payload {return v}
      return Pincer_Protocol_V1_StreamGap()
    }
    set {_uniqueStorage()._payload = .streamGap(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case turnStarted(Pincer_Protocol_V1_TurnStarted)
    case turnBudgetApplied(Pincer_Protocol_V1_TurnBudgetApplied)
    case modelOutputRepairAttempted(Pincer_Protocol_V1_ModelOutputRepairAttempted)
    case turnCompleted(Pincer_Protocol_V1_TurnCompleted)
    case turnFailed(Pincer_Protocol_V1_TurnFailed)
    case assistantThinkingDelta(Pincer_Protocol_V1_AssistantThinkingDelta)
    case assistantTextDelta(Pincer_Protocol_V1_AssistantTextDelta)
    case assistantMessageCommitted(Pincer_Protocol_V1_AssistantMessageCommitted)
    case toolCallPlanned(Pincer_Protocol_V1_ToolCallPlanned)
    case toolExecutionStarted(Pincer_Protocol_V1_ToolExecutionStarted)
    case toolExecutionOutputDelta(Pincer_Protocol_V1_ToolExecutionOutputDelta)
    case toolExecutionFinished(Pincer_Protocol_V1_ToolExecutionFinished)
    case policyDecisionMade(Pincer_Protocol_V1_PolicyDecisionMade)
    case proposedActionCreated(Pincer_Protocol_V1_ProposedActionCreated)
    case proposedActionStatusChanged(Pincer_Protocol_V1_ProposedActionStatusChanged)
    case idempotencyConflict(Pincer_Protocol_V1_IdempotencyConflict)
    case jobStatusChanged(Pincer_Protocol_V1_JobStatusChanged)
    case scheduleTriggered(Pincer_Protocol_V1_ScheduleTriggered)
    case delegatedCallbackReceived(Pincer_Protocol_V1_DelegatedCallbackReceived)
    case auditEventRecorded(Pincer_Protocol_V1_AuditEventRecorded)
    case notificationQueued(Pincer_Protocol_V1_NotificationQueued)
    case artifactCreated(Pincer_Protocol_V1_ArtifactCreated)
    case memoryCheckpointSaved(Pincer_Protocol_V1_MemoryCheckpointSaved)
    case skillProposalCreated(Pincer_Protocol_V1_SkillProposalCreated)
    case selfImprovementProposalCreated(Pincer_Protocol_V1_SelfImprovementProposalCreated)
    case heartbeat(Pincer_Protocol_V1_Heartbeat)
    case streamGap(Pincer_Protocol_V1_StreamGap)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pincer_Protocol_V1_TurnStarted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userMessageID: String = String()

  public var triggerType: Pincer_Protocol_V1_TriggerType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_TurnBudgetApplied: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var effectiveBudget: Pincer_Protocol_V1_TurnBudget {
    get {_effectiveBudget ?? Pincer_Protocol_V1_TurnBudget()}
    set {_effectiveBudget = newValue}
  }
  /// Returns true if `effectiveBudget` has been explicitly set.
  public var hasEffectiveBudget: Bool {self._effectiveBudget != nil}
  /// Clears the value of `effectiveBudget`. Subsequent reads from it will return its default value.
  public mutating func clearEffectiveBudget() {self._effectiveBudget = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _effectiveBudget: Pincer_Protocol_V1_TurnBudget? = nil
}

public struct Pincer_Protocol_V1_ModelOutputRepairAttempted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var repairAttempt: UInt32 = 0

  public var fallbackModelUsed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_TurnCompleted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assistantMessageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_TurnFailed: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var retryable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_AssistantThinkingDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var segmentID: String = String()

  public var delta: String = String()

  public var redacted: Bool = false

  public var visibility: Pincer_Protocol_V1_ReasoningVisibility = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_AssistantTextDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var segmentID: String = String()

  public var delta: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_AssistantMessageCommitted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var fullText: String = String()

  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {_metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pincer_Protocol_V1_ToolCallPlanned: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var toolCallID: String = String()

  public var toolName: String = String()

  public var args: SwiftProtobuf.Google_Protobuf_Struct {
    get {_args ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_args = newValue}
  }
  /// Returns true if `args` has been explicitly set.
  public var hasArgs: Bool {self._args != nil}
  /// Clears the value of `args`. Subsequent reads from it will return its default value.
  public mutating func clearArgs() {self._args = nil}

  public var riskClass: Pincer_Protocol_V1_RiskClass = .unspecified

  public var identity: Pincer_Protocol_V1_Identity = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _args: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pincer_Protocol_V1_ToolExecutionStarted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var executionID: String = String()

  public var toolCallID: String = String()

  public var toolName: String = String()

  public var displayCommand: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ToolExecutionOutputDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var executionID: String = String()

  public var stream: Pincer_Protocol_V1_OutputStream = .unspecified

  public var chunk: Data = Data()

  public var offsetBytes: UInt64 = 0

  public var utf8: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ToolExecutionFinished: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var executionID: String = String()

  public var exitCode: Int32 = 0

  public var durationMs: UInt64 = 0

  public var timedOut: Bool = false

  public var truncated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_PolicyDecisionMade: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var policyID: String = String()

  public var decision: Pincer_Protocol_V1_PolicyDecision = .unspecified

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ProposedActionCreated: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var tool: String = String()

  public var riskClass: Pincer_Protocol_V1_RiskClass = .unspecified

  public var identity: Pincer_Protocol_V1_Identity = .unspecified

  public var idempotencyKey: String = String()

  public var justification: String = String()

  public var deterministicSummary: String = String()

  public var preview: SwiftProtobuf.Google_Protobuf_Struct {
    get {_preview ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  public var hasPreview: Bool {self._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  public mutating func clearPreview() {self._preview = nil}

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _preview: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ProposedActionStatusChanged: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var status: Pincer_Protocol_V1_ActionStatus = .unspecified

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_IdempotencyConflict: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var tool: String = String()

  public var idempotencyKey: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_JobStatusChanged: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var status: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ScheduleTriggered: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scheduleID: String = String()

  public var scheduledForUtc: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_scheduledForUtc ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_scheduledForUtc = newValue}
  }
  /// Returns true if `scheduledForUtc` has been explicitly set.
  public var hasScheduledForUtc: Bool {self._scheduledForUtc != nil}
  /// Clears the value of `scheduledForUtc`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledForUtc() {self._scheduledForUtc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scheduledForUtc: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_DelegatedCallbackReceived: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callbackID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_AuditEventRecorded: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entryID: String = String()

  public var eventType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_NotificationQueued: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationID: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ArtifactCreated: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artifactID: String = String()

  public var threadID: String = String()

  public var mediaType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_MemoryCheckpointSaved: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var checkpointID: String = String()

  public var scope: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_SkillProposalCreated: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposalID: String = String()

  public var title: String = String()

  public var requiresOwnerApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_SelfImprovementProposalCreated: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposalID: String = String()

  public var kind: String = String()

  public var requiresOwnerApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_Heartbeat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var latestSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_StreamGap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestedFromSequence: UInt64 = 0

  public var nextAvailableSequence: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_Approval: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var source: String = String()

  public var sourceID: String = String()

  public var tool: String = String()

  public var status: Pincer_Protocol_V1_ActionStatus = .unspecified

  public var riskClass: Pincer_Protocol_V1_RiskClass = .unspecified

  public var identity: Pincer_Protocol_V1_Identity = .unspecified

  public var deterministicSummary: String = String()

  public var preview: SwiftProtobuf.Google_Protobuf_Struct {
    get {_preview ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  public var hasPreview: Bool {self._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  public mutating func clearPreview() {self._preview = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var rejectionReason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _preview: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListApprovalsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Pincer_Protocol_V1_ActionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListApprovalsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_Approval] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ApproveActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ApproveActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var status: Pincer_Protocol_V1_ActionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RejectActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RejectActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionID: String = String()

  public var status: Pincer_Protocol_V1_ActionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_Job: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var goal: String = String()

  public var status: Pincer_Protocol_V1_JobStatus = .unspecified

  public var threadID: String = String()

  public var triggerType: Pincer_Protocol_V1_TriggerType = .unspecified

  public var triggerSourceID: String = String()

  public var budget: Pincer_Protocol_V1_TurnBudget {
    get {_budget ?? Pincer_Protocol_V1_TurnBudget()}
    set {_budget = newValue}
  }
  /// Returns true if `budget` has been explicitly set.
  public var hasBudget: Bool {self._budget != nil}
  /// Clears the value of `budget`. Subsequent reads from it will return its default value.
  public mutating func clearBudget() {self._budget = nil}

  public var maxWallTimeMs: UInt64 = 0

  public var lastError: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _budget: Pincer_Protocol_V1_TurnBudget? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListJobsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListJobsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_Job] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreateJobRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var goal: String = String()

  public var budget: Pincer_Protocol_V1_TurnBudget {
    get {_budget ?? Pincer_Protocol_V1_TurnBudget()}
    set {_budget = newValue}
  }
  /// Returns true if `budget` has been explicitly set.
  public var hasBudget: Bool {self._budget != nil}
  /// Clears the value of `budget`. Subsequent reads from it will return its default value.
  public mutating func clearBudget() {self._budget = nil}

  public var maxWallTimeMs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _budget: Pincer_Protocol_V1_TurnBudget? = nil
}

public struct Pincer_Protocol_V1_CreateJobResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Pincer_Protocol_V1_Job {
    get {_item ?? Pincer_Protocol_V1_Job()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Pincer_Protocol_V1_Job? = nil
}

public struct Pincer_Protocol_V1_GetJobRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_GetJobResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Pincer_Protocol_V1_Job {
    get {_item ?? Pincer_Protocol_V1_Job()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Pincer_Protocol_V1_Job? = nil
}

public struct Pincer_Protocol_V1_CancelJobRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CancelJobResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jobID: String = String()

  public var status: Pincer_Protocol_V1_JobStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_Schedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scheduleID: String = String()

  public var name: String = String()

  public var triggerKind: Pincer_Protocol_V1_ScheduleTriggerKind = .unspecified

  public var triggerSpec: String = String()

  public var timezone: String = String()

  public var enabled: Bool = false

  public var nextRunAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_nextRunAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextRunAt = newValue}
  }
  /// Returns true if `nextRunAt` has been explicitly set.
  public var hasNextRunAt: Bool {self._nextRunAt != nil}
  /// Clears the value of `nextRunAt`. Subsequent reads from it will return its default value.
  public mutating func clearNextRunAt() {self._nextRunAt = nil}

  public var lastRunAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_lastRunAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastRunAt = newValue}
  }
  /// Returns true if `lastRunAt` has been explicitly set.
  public var hasLastRunAt: Bool {self._lastRunAt != nil}
  /// Clears the value of `lastRunAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastRunAt() {self._lastRunAt = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextRunAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastRunAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListSchedulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListSchedulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_Schedule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreateScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var triggerKind: Pincer_Protocol_V1_ScheduleTriggerKind = .unspecified

  public var triggerSpec: String = String()

  public var timezone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_CreateScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Pincer_Protocol_V1_Schedule {
    get {_item ?? Pincer_Protocol_V1_Schedule()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Pincer_Protocol_V1_Schedule? = nil
}

public struct Pincer_Protocol_V1_UpdateScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scheduleID: String = String()

  public var patch: SwiftProtobuf.Google_Protobuf_Struct {
    get {_patch ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  public var hasPatch: Bool {self._patch != nil}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  public mutating func clearPatch() {self._patch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _patch: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pincer_Protocol_V1_UpdateScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Pincer_Protocol_V1_Schedule {
    get {_item ?? Pincer_Protocol_V1_Schedule()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Pincer_Protocol_V1_Schedule? = nil
}

public struct Pincer_Protocol_V1_RunScheduleNowRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scheduleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_RunScheduleNowResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scheduleID: String = String()

  public var wakeupEventID: String = String()

  public var jobID: String = String()

  public var turnID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_GetPolicySummaryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_GetPolicySummaryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var summary: SwiftProtobuf.Google_Protobuf_Struct {
    get {_summary ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var policyVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _summary: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pincer_Protocol_V1_AuditEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entryID: String = String()

  public var eventType: String = String()

  public var threadID: String = String()

  public var jobID: String = String()

  public var actionID: String = String()

  public var payload: SwiftProtobuf.Google_Protobuf_Struct {
    get {_payload ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_occurredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_occurredAt = newValue}
  }
  /// Returns true if `occurredAt` has been explicitly set.
  public var hasOccurredAt: Bool {self._occurredAt != nil}
  /// Clears the value of `occurredAt`. Subsequent reads from it will return its default value.
  public mutating func clearOccurredAt() {self._occurredAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListAuditRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListAuditResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_AuditEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_Notification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationID: String = String()

  public var type: Pincer_Protocol_V1_NotificationType = .unspecified

  public var resourceKind: String = String()

  public var resourceID: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var readAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_readAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  public var hasReadAt: Bool {self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  public mutating func clearReadAt() {self._readAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _readAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pincer_Protocol_V1_ListNotificationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pincer_Protocol_V1_ListNotificationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: [Pincer_Protocol_V1_Notification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pincer.protocol.v1"

extension Pincer_Protocol_V1_QueueMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0QUEUE_MODE_UNSPECIFIED\0\u{1}REJECT_IF_BUSY\0\u{1}INTERRUPT_AFTER_CURRENT_TOOL\0\u{1}QUEUE_AFTER_TURN\0")
}

extension Pincer_Protocol_V1_ReasoningVisibility: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0REASONING_VISIBILITY_UNSPECIFIED\0\u{1}REASONING_OFF\0\u{1}REASONING_SUMMARY\0\u{1}REASONING_RAW\0")
}

extension Pincer_Protocol_V1_EventSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0EVENT_SOURCE_UNSPECIFIED\0\u{1}MODEL_UNTRUSTED\0\u{1}POLICY_ENGINE\0\u{1}TOOL_EXECUTOR\0\u{1}SYSTEM\0")
}

extension Pincer_Protocol_V1_ContentTrust: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONTENT_TRUST_UNSPECIFIED\0\u{1}UNTRUSTED_MODEL\0\u{1}TRUSTED_VALIDATED\0\u{1}TRUSTED_SYSTEM\0")
}

extension Pincer_Protocol_V1_Identity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0IDENTITY_UNSPECIFIED\0\u{1}IDENTITY_USER\0\u{1}IDENTITY_BOT\0\u{1}IDENTITY_NONE\0")
}

extension Pincer_Protocol_V1_RiskClass: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RISK_CLASS_UNSPECIFIED\0\u{1}READ\0\u{1}WRITE\0\u{1}EXFILTRATION\0\u{1}DESTRUCTIVE\0\u{1}HIGH\0")
}

extension Pincer_Protocol_V1_PolicyDecision: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0POLICY_DECISION_UNSPECIFIED\0\u{1}ALLOW_INTERNAL\0\u{1}REQUIRE_APPROVAL\0\u{1}BLOCKED\0")
}

extension Pincer_Protocol_V1_ActionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ACTION_STATUS_UNSPECIFIED\0\u{1}PENDING\0\u{1}APPROVED\0\u{1}REJECTED\0\u{1}EXECUTED\0")
}

extension Pincer_Protocol_V1_OutputStream: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OUTPUT_STREAM_UNSPECIFIED\0\u{1}STDOUT\0\u{1}STDERR\0")
}

extension Pincer_Protocol_V1_TriggerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TRIGGER_TYPE_UNSPECIFIED\0\u{1}CHAT_MESSAGE\0\u{1}JOB_WAKEUP\0\u{1}SCHEDULE_WAKEUP\0\u{1}HEARTBEAT\0\u{1}DELEGATED_CALLBACK\0")
}

extension Pincer_Protocol_V1_JobStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0JOB_STATUS_UNSPECIFIED\0\u{1}JOB_RUNNING\0\u{1}JOB_WAITING_APPROVAL\0\u{1}JOB_COMPLETED\0\u{1}JOB_FAILED\0\u{1}JOB_PAUSED_BUDGET\0\u{1}JOB_CANCELLED\0")
}

extension Pincer_Protocol_V1_ScheduleTriggerKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SCHEDULE_TRIGGER_KIND_UNSPECIFIED\0\u{1}SCHEDULE_TRIGGER_CRON\0\u{1}SCHEDULE_TRIGGER_INTERVAL\0\u{1}SCHEDULE_TRIGGER_AT\0")
}

extension Pincer_Protocol_V1_NotificationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOTIFICATION_TYPE_UNSPECIFIED\0\u{1}NOTIFICATION_PENDING_APPROVAL_CREATED\0\u{1}NOTIFICATION_APPROVAL_EXPIRING_SOON\0\u{1}NOTIFICATION_JOB_COMPLETED\0\u{1}NOTIFICATION_JOB_FAILED\0\u{1}NOTIFICATION_PROACTIVE_REACH_OUT\0")
}

extension Pincer_Protocol_V1_CreatePairingCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePairingCodeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreatePairingCodeRequest, rhs: Pincer_Protocol_V1_CreatePairingCodeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreatePairingCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePairingCodeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{3}expires_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreatePairingCodeResponse, rhs: Pincer_Protocol_V1_CreatePairingCodeResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_BindPairingCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindPairingCodeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{3}device_name\0\u{3}public_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_BindPairingCodeRequest, rhs: Pincer_Protocol_V1_BindPairingCodeRequest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_BindPairingCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindPairingCodeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}token\0\u{3}expires_at\0\u{3}renew_after\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._renewAfter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._renewAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_BindPairingCodeResponse, rhs: Pincer_Protocol_V1_BindPairingCodeResponse) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.token != rhs.token {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs._renewAfter != rhs._renewAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RotateTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RotateTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RotateTokenRequest, rhs: Pincer_Protocol_V1_RotateTokenRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RotateTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RotateTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}expires_at\0\u{3}renew_after\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._renewAfter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._renewAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RotateTokenResponse, rhs: Pincer_Protocol_V1_RotateTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs._renewAfter != rhs._renewAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}name\0\u{3}is_current\0\u{3}created_at\0\u{3}revoked_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isCurrent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._revokedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.isCurrent != false {
      try visitor.visitSingularBoolField(value: self.isCurrent, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._revokedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Device, rhs: Pincer_Protocol_V1_Device) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.isCurrent != rhs.isCurrent {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._revokedAt != rhs._revokedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDevicesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListDevicesRequest, rhs: Pincer_Protocol_V1_ListDevicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDevicesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListDevicesResponse, rhs: Pincer_Protocol_V1_ListDevicesResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RevokeDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RevokeDeviceRequest, rhs: Pincer_Protocol_V1_RevokeDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RevokeDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RevokeDeviceResponse, rhs: Pincer_Protocol_V1_RevokeDeviceResponse) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateThreadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateThreadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateThreadRequest, rhs: Pincer_Protocol_V1_CreateThreadRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateThreadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateThreadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}last_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if self.lastSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSequence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateThreadResponse, rhs: Pincer_Protocol_V1_CreateThreadResponse) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.lastSequence != rhs.lastSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_TurnBudget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnBudget"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}max_tool_steps\0\u{3}max_tool_tokens\0\u{3}max_context_messages\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxToolSteps) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxToolTokens) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxContextMessages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxToolSteps != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxToolSteps, fieldNumber: 1)
    }
    if self.maxToolTokens != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxToolTokens, fieldNumber: 2)
    }
    if self.maxContextMessages != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxContextMessages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_TurnBudget, rhs: Pincer_Protocol_V1_TurnBudget) -> Bool {
    if lhs.maxToolSteps != rhs.maxToolSteps {return false}
    if lhs.maxToolTokens != rhs.maxToolTokens {return false}
    if lhs.maxContextMessages != rhs.maxContextMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_StartTurnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartTurnRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}client_message_id\0\u{3}user_text\0\u{3}queue_mode\0\u{3}reasoning_visibility\0\u{3}trigger_type\0\u{3}trigger_source_id\0\u{3}requested_budget\0\u{3}resume_from_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientMessageID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userText) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.queueMode) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reasoningVisibility) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.triggerType) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.triggerSourceID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._requestedBudget) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.resumeFromSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if !self.clientMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientMessageID, fieldNumber: 2)
    }
    if !self.userText.isEmpty {
      try visitor.visitSingularStringField(value: self.userText, fieldNumber: 3)
    }
    if self.queueMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.queueMode, fieldNumber: 4)
    }
    if self.reasoningVisibility != .unspecified {
      try visitor.visitSingularEnumField(value: self.reasoningVisibility, fieldNumber: 5)
    }
    if self.triggerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerType, fieldNumber: 6)
    }
    if !self.triggerSourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerSourceID, fieldNumber: 7)
    }
    try { if let v = self._requestedBudget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.resumeFromSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.resumeFromSequence, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_StartTurnRequest, rhs: Pincer_Protocol_V1_StartTurnRequest) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.clientMessageID != rhs.clientMessageID {return false}
    if lhs.userText != rhs.userText {return false}
    if lhs.queueMode != rhs.queueMode {return false}
    if lhs.reasoningVisibility != rhs.reasoningVisibility {return false}
    if lhs.triggerType != rhs.triggerType {return false}
    if lhs.triggerSourceID != rhs.triggerSourceID {return false}
    if lhs._requestedBudget != rhs._requestedBudget {return false}
    if lhs.resumeFromSequence != rhs.resumeFromSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_SendTurnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendTurnRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}user_text\0\u{3}trigger_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userText) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.triggerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if !self.userText.isEmpty {
      try visitor.visitSingularStringField(value: self.userText, fieldNumber: 2)
    }
    if self.triggerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_SendTurnRequest, rhs: Pincer_Protocol_V1_SendTurnRequest) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.userText != rhs.userText {return false}
    if lhs.triggerType != rhs.triggerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_SendTurnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendTurnResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}turn_id\0\u{3}assistant_message\0\u{3}action_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.turnID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.assistantMessage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.turnID.isEmpty {
      try visitor.visitSingularStringField(value: self.turnID, fieldNumber: 1)
    }
    if !self.assistantMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.assistantMessage, fieldNumber: 2)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_SendTurnResponse, rhs: Pincer_Protocol_V1_SendTurnResponse) -> Bool {
    if lhs.turnID != rhs.turnID {return false}
    if lhs.assistantMessage != rhs.assistantMessage {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_WatchThreadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchThreadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}from_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fromSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if self.fromSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromSequence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_WatchThreadRequest, rhs: Pincer_Protocol_V1_WatchThreadRequest) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.fromSequence != rhs.fromSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetThreadSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetThreadSnapshotRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetThreadSnapshotRequest, rhs: Pincer_Protocol_V1_GetThreadSnapshotRequest) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListThreadMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListThreadMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListThreadMessagesRequest, rhs: Pincer_Protocol_V1_ListThreadMessagesRequest) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ThreadMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreadMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{1}role\0\u{1}content\0\u{1}metadata\0\u{3}content_trust\0\u{3}created_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.contentTrust) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.contentTrust != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentTrust, fieldNumber: 5)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ThreadMessage, rhs: Pincer_Protocol_V1_ThreadMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.content != rhs.content {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.contentTrust != rhs.contentTrust {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetThreadSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetThreadSnapshotResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}thread_id\0\u{3}last_sequence\0\u{1}messages\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastSequence) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 1)
    }
    if self.lastSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSequence, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetThreadSnapshotResponse, rhs: Pincer_Protocol_V1_GetThreadSnapshotResponse) -> Bool {
    if lhs.threadID != rhs.threadID {return false}
    if lhs.lastSequence != rhs.lastSequence {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListThreadMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListThreadMessagesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0\u{3}next_page_token\0\u{3}last_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lastSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.lastSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListThreadMessagesResponse, rhs: Pincer_Protocol_V1_ListThreadMessagesResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.lastSequence != rhs.lastSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ThreadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreadEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}thread_id\0\u{3}job_id\0\u{3}turn_id\0\u{1}sequence\0\u{3}occurred_at\0\u{1}source\0\u{3}content_trust\0\u{4}\u{c}turn_started\0\u{3}turn_budget_applied\0\u{3}model_output_repair_attempted\0\u{3}turn_completed\0\u{3}turn_failed\0\u{4}\u{6}assistant_thinking_delta\0\u{3}assistant_text_delta\0\u{3}assistant_message_committed\0\u{4}\u{8}tool_call_planned\0\u{3}tool_execution_started\0\u{3}tool_execution_output_delta\0\u{3}tool_execution_finished\0\u{4}\u{7}policy_decision_made\0\u{3}proposed_action_created\0\u{3}proposed_action_status_changed\0\u{3}idempotency_conflict\0\u{4}\u{7}job_status_changed\0\u{3}schedule_triggered\0\u{3}delegated_callback_received\0\u{4}\u{8}audit_event_recorded\0\u{3}notification_queued\0\u{3}artifact_created\0\u{3}memory_checkpoint_saved\0\u{3}skill_proposal_created\0\u{3}self_improvement_proposal_created\0\u{2}\u{f}heartbeat\0\u{3}stream_gap\0")

  fileprivate class _StorageClass {
    var _eventID: String = String()
    var _threadID: String = String()
    var _jobID: String = String()
    var _turnID: String = String()
    var _sequence: UInt64 = 0
    var _occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _source: Pincer_Protocol_V1_EventSource = .unspecified
    var _contentTrust: Pincer_Protocol_V1_ContentTrust = .unspecified
    var _payload: Pincer_Protocol_V1_ThreadEvent.OneOf_Payload?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _eventID = source._eventID
      _threadID = source._threadID
      _jobID = source._jobID
      _turnID = source._turnID
      _sequence = source._sequence
      _occurredAt = source._occurredAt
      _source = source._source
      _contentTrust = source._contentTrust
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._eventID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._threadID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._jobID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._turnID) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._sequence) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._occurredAt) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._source) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._contentTrust) }()
        case 20: try {
          var v: Pincer_Protocol_V1_TurnStarted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .turnStarted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .turnStarted(v)
          }
        }()
        case 21: try {
          var v: Pincer_Protocol_V1_TurnBudgetApplied?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .turnBudgetApplied(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .turnBudgetApplied(v)
          }
        }()
        case 22: try {
          var v: Pincer_Protocol_V1_ModelOutputRepairAttempted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .modelOutputRepairAttempted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .modelOutputRepairAttempted(v)
          }
        }()
        case 23: try {
          var v: Pincer_Protocol_V1_TurnCompleted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .turnCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .turnCompleted(v)
          }
        }()
        case 24: try {
          var v: Pincer_Protocol_V1_TurnFailed?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .turnFailed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .turnFailed(v)
          }
        }()
        case 30: try {
          var v: Pincer_Protocol_V1_AssistantThinkingDelta?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .assistantThinkingDelta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .assistantThinkingDelta(v)
          }
        }()
        case 31: try {
          var v: Pincer_Protocol_V1_AssistantTextDelta?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .assistantTextDelta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .assistantTextDelta(v)
          }
        }()
        case 32: try {
          var v: Pincer_Protocol_V1_AssistantMessageCommitted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .assistantMessageCommitted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .assistantMessageCommitted(v)
          }
        }()
        case 40: try {
          var v: Pincer_Protocol_V1_ToolCallPlanned?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .toolCallPlanned(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .toolCallPlanned(v)
          }
        }()
        case 41: try {
          var v: Pincer_Protocol_V1_ToolExecutionStarted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .toolExecutionStarted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .toolExecutionStarted(v)
          }
        }()
        case 42: try {
          var v: Pincer_Protocol_V1_ToolExecutionOutputDelta?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .toolExecutionOutputDelta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .toolExecutionOutputDelta(v)
          }
        }()
        case 43: try {
          var v: Pincer_Protocol_V1_ToolExecutionFinished?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .toolExecutionFinished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .toolExecutionFinished(v)
          }
        }()
        case 50: try {
          var v: Pincer_Protocol_V1_PolicyDecisionMade?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .policyDecisionMade(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .policyDecisionMade(v)
          }
        }()
        case 51: try {
          var v: Pincer_Protocol_V1_ProposedActionCreated?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .proposedActionCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .proposedActionCreated(v)
          }
        }()
        case 52: try {
          var v: Pincer_Protocol_V1_ProposedActionStatusChanged?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .proposedActionStatusChanged(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .proposedActionStatusChanged(v)
          }
        }()
        case 53: try {
          var v: Pincer_Protocol_V1_IdempotencyConflict?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .idempotencyConflict(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .idempotencyConflict(v)
          }
        }()
        case 60: try {
          var v: Pincer_Protocol_V1_JobStatusChanged?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .jobStatusChanged(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .jobStatusChanged(v)
          }
        }()
        case 61: try {
          var v: Pincer_Protocol_V1_ScheduleTriggered?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .scheduleTriggered(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .scheduleTriggered(v)
          }
        }()
        case 62: try {
          var v: Pincer_Protocol_V1_DelegatedCallbackReceived?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .delegatedCallbackReceived(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .delegatedCallbackReceived(v)
          }
        }()
        case 70: try {
          var v: Pincer_Protocol_V1_AuditEventRecorded?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .auditEventRecorded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .auditEventRecorded(v)
          }
        }()
        case 71: try {
          var v: Pincer_Protocol_V1_NotificationQueued?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .notificationQueued(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .notificationQueued(v)
          }
        }()
        case 72: try {
          var v: Pincer_Protocol_V1_ArtifactCreated?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .artifactCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .artifactCreated(v)
          }
        }()
        case 73: try {
          var v: Pincer_Protocol_V1_MemoryCheckpointSaved?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .memoryCheckpointSaved(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .memoryCheckpointSaved(v)
          }
        }()
        case 74: try {
          var v: Pincer_Protocol_V1_SkillProposalCreated?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .skillProposalCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .skillProposalCreated(v)
          }
        }()
        case 75: try {
          var v: Pincer_Protocol_V1_SelfImprovementProposalCreated?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .selfImprovementProposalCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .selfImprovementProposalCreated(v)
          }
        }()
        case 90: try {
          var v: Pincer_Protocol_V1_Heartbeat?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .heartbeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .heartbeat(v)
          }
        }()
        case 91: try {
          var v: Pincer_Protocol_V1_StreamGap?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .streamGap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .streamGap(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._eventID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventID, fieldNumber: 1)
      }
      if !_storage._threadID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._threadID, fieldNumber: 2)
      }
      if !_storage._jobID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobID, fieldNumber: 3)
      }
      if !_storage._turnID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._turnID, fieldNumber: 4)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._sequence, fieldNumber: 5)
      }
      try { if let v = _storage._occurredAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._source != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 7)
      }
      if _storage._contentTrust != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._contentTrust, fieldNumber: 8)
      }
      switch _storage._payload {
      case .turnStarted?: try {
        guard case .turnStarted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .turnBudgetApplied?: try {
        guard case .turnBudgetApplied(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .modelOutputRepairAttempted?: try {
        guard case .modelOutputRepairAttempted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .turnCompleted?: try {
        guard case .turnCompleted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .turnFailed?: try {
        guard case .turnFailed(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .assistantThinkingDelta?: try {
        guard case .assistantThinkingDelta(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .assistantTextDelta?: try {
        guard case .assistantTextDelta(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .assistantMessageCommitted?: try {
        guard case .assistantMessageCommitted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .toolCallPlanned?: try {
        guard case .toolCallPlanned(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .toolExecutionStarted?: try {
        guard case .toolExecutionStarted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .toolExecutionOutputDelta?: try {
        guard case .toolExecutionOutputDelta(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .toolExecutionFinished?: try {
        guard case .toolExecutionFinished(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .policyDecisionMade?: try {
        guard case .policyDecisionMade(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .proposedActionCreated?: try {
        guard case .proposedActionCreated(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .proposedActionStatusChanged?: try {
        guard case .proposedActionStatusChanged(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .idempotencyConflict?: try {
        guard case .idempotencyConflict(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .jobStatusChanged?: try {
        guard case .jobStatusChanged(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case .scheduleTriggered?: try {
        guard case .scheduleTriggered(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }()
      case .delegatedCallbackReceived?: try {
        guard case .delegatedCallbackReceived(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }()
      case .auditEventRecorded?: try {
        guard case .auditEventRecorded(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }()
      case .notificationQueued?: try {
        guard case .notificationQueued(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }()
      case .artifactCreated?: try {
        guard case .artifactCreated(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }()
      case .memoryCheckpointSaved?: try {
        guard case .memoryCheckpointSaved(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      }()
      case .skillProposalCreated?: try {
        guard case .skillProposalCreated(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      }()
      case .selfImprovementProposalCreated?: try {
        guard case .selfImprovementProposalCreated(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      }()
      case .heartbeat?: try {
        guard case .heartbeat(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      }()
      case .streamGap?: try {
        guard case .streamGap(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ThreadEvent, rhs: Pincer_Protocol_V1_ThreadEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._eventID != rhs_storage._eventID {return false}
        if _storage._threadID != rhs_storage._threadID {return false}
        if _storage._jobID != rhs_storage._jobID {return false}
        if _storage._turnID != rhs_storage._turnID {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._occurredAt != rhs_storage._occurredAt {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._contentTrust != rhs_storage._contentTrust {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_TurnStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnStarted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_message_id\0\u{3}trigger_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userMessageID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.triggerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.userMessageID, fieldNumber: 1)
    }
    if self.triggerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_TurnStarted, rhs: Pincer_Protocol_V1_TurnStarted) -> Bool {
    if lhs.userMessageID != rhs.userMessageID {return false}
    if lhs.triggerType != rhs.triggerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_TurnBudgetApplied: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnBudgetApplied"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}effective_budget\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effectiveBudget) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._effectiveBudget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_TurnBudgetApplied, rhs: Pincer_Protocol_V1_TurnBudgetApplied) -> Bool {
    if lhs._effectiveBudget != rhs._effectiveBudget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ModelOutputRepairAttempted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelOutputRepairAttempted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}repair_attempt\0\u{3}fallback_model_used\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.repairAttempt) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fallbackModelUsed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.repairAttempt != 0 {
      try visitor.visitSingularUInt32Field(value: self.repairAttempt, fieldNumber: 1)
    }
    if self.fallbackModelUsed != false {
      try visitor.visitSingularBoolField(value: self.fallbackModelUsed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ModelOutputRepairAttempted, rhs: Pincer_Protocol_V1_ModelOutputRepairAttempted) -> Bool {
    if lhs.repairAttempt != rhs.repairAttempt {return false}
    if lhs.fallbackModelUsed != rhs.fallbackModelUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_TurnCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnCompleted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}assistant_message_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.assistantMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assistantMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.assistantMessageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_TurnCompleted, rhs: Pincer_Protocol_V1_TurnCompleted) -> Bool {
    if lhs.assistantMessageID != rhs.assistantMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_TurnFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnFailed"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{1}retryable\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.retryable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.retryable != false {
      try visitor.visitSingularBoolField(value: self.retryable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_TurnFailed, rhs: Pincer_Protocol_V1_TurnFailed) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.retryable != rhs.retryable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_AssistantThinkingDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistantThinkingDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}segment_id\0\u{1}delta\0\u{1}redacted\0\u{1}visibility\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.segmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.delta) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.redacted) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentID, fieldNumber: 1)
    }
    if !self.delta.isEmpty {
      try visitor.visitSingularStringField(value: self.delta, fieldNumber: 2)
    }
    if self.redacted != false {
      try visitor.visitSingularBoolField(value: self.redacted, fieldNumber: 3)
    }
    if self.visibility != .unspecified {
      try visitor.visitSingularEnumField(value: self.visibility, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_AssistantThinkingDelta, rhs: Pincer_Protocol_V1_AssistantThinkingDelta) -> Bool {
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.delta != rhs.delta {return false}
    if lhs.redacted != rhs.redacted {return false}
    if lhs.visibility != rhs.visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_AssistantTextDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistantTextDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}segment_id\0\u{1}delta\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.segmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.delta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentID, fieldNumber: 1)
    }
    if !self.delta.isEmpty {
      try visitor.visitSingularStringField(value: self.delta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_AssistantTextDelta, rhs: Pincer_Protocol_V1_AssistantTextDelta) -> Bool {
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.delta != rhs.delta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_AssistantMessageCommitted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistantMessageCommitted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{3}full_text\0\u{1}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullText) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.fullText.isEmpty {
      try visitor.visitSingularStringField(value: self.fullText, fieldNumber: 2)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_AssistantMessageCommitted, rhs: Pincer_Protocol_V1_AssistantMessageCommitted) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.fullText != rhs.fullText {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ToolCallPlanned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolCallPlanned"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}tool_call_id\0\u{3}tool_name\0\u{1}args\0\u{3}risk_class\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toolCallID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toolName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._args) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.riskClass) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.toolCallID.isEmpty {
      try visitor.visitSingularStringField(value: self.toolCallID, fieldNumber: 1)
    }
    if !self.toolName.isEmpty {
      try visitor.visitSingularStringField(value: self.toolName, fieldNumber: 2)
    }
    try { if let v = self._args {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.riskClass != .unspecified {
      try visitor.visitSingularEnumField(value: self.riskClass, fieldNumber: 4)
    }
    if self.identity != .unspecified {
      try visitor.visitSingularEnumField(value: self.identity, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ToolCallPlanned, rhs: Pincer_Protocol_V1_ToolCallPlanned) -> Bool {
    if lhs.toolCallID != rhs.toolCallID {return false}
    if lhs.toolName != rhs.toolName {return false}
    if lhs._args != rhs._args {return false}
    if lhs.riskClass != rhs.riskClass {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ToolExecutionStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolExecutionStarted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_id\0\u{3}tool_call_id\0\u{3}tool_name\0\u{3}display_command\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.executionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toolCallID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toolName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayCommand) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executionID.isEmpty {
      try visitor.visitSingularStringField(value: self.executionID, fieldNumber: 1)
    }
    if !self.toolCallID.isEmpty {
      try visitor.visitSingularStringField(value: self.toolCallID, fieldNumber: 2)
    }
    if !self.toolName.isEmpty {
      try visitor.visitSingularStringField(value: self.toolName, fieldNumber: 3)
    }
    if !self.displayCommand.isEmpty {
      try visitor.visitSingularStringField(value: self.displayCommand, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ToolExecutionStarted, rhs: Pincer_Protocol_V1_ToolExecutionStarted) -> Bool {
    if lhs.executionID != rhs.executionID {return false}
    if lhs.toolCallID != rhs.toolCallID {return false}
    if lhs.toolName != rhs.toolName {return false}
    if lhs.displayCommand != rhs.displayCommand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ToolExecutionOutputDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolExecutionOutputDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_id\0\u{1}stream\0\u{1}chunk\0\u{3}offset_bytes\0\u{1}utf8\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.executionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stream) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.offsetBytes) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.utf8) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executionID.isEmpty {
      try visitor.visitSingularStringField(value: self.executionID, fieldNumber: 1)
    }
    if self.stream != .unspecified {
      try visitor.visitSingularEnumField(value: self.stream, fieldNumber: 2)
    }
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 3)
    }
    if self.offsetBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.offsetBytes, fieldNumber: 4)
    }
    if self.utf8 != false {
      try visitor.visitSingularBoolField(value: self.utf8, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ToolExecutionOutputDelta, rhs: Pincer_Protocol_V1_ToolExecutionOutputDelta) -> Bool {
    if lhs.executionID != rhs.executionID {return false}
    if lhs.stream != rhs.stream {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.offsetBytes != rhs.offsetBytes {return false}
    if lhs.utf8 != rhs.utf8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ToolExecutionFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolExecutionFinished"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_id\0\u{3}exit_code\0\u{3}duration_ms\0\u{3}timed_out\0\u{1}truncated\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.executionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.timedOut) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.truncated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executionID.isEmpty {
      try visitor.visitSingularStringField(value: self.executionID, fieldNumber: 1)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.timedOut != false {
      try visitor.visitSingularBoolField(value: self.timedOut, fieldNumber: 4)
    }
    if self.truncated != false {
      try visitor.visitSingularBoolField(value: self.truncated, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ToolExecutionFinished, rhs: Pincer_Protocol_V1_ToolExecutionFinished) -> Bool {
    if lhs.executionID != rhs.executionID {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.timedOut != rhs.timedOut {return false}
    if lhs.truncated != rhs.truncated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_PolicyDecisionMade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyDecisionMade"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}policy_id\0\u{1}decision\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.policyID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.decision) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.policyID.isEmpty {
      try visitor.visitSingularStringField(value: self.policyID, fieldNumber: 1)
    }
    if self.decision != .unspecified {
      try visitor.visitSingularEnumField(value: self.decision, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_PolicyDecisionMade, rhs: Pincer_Protocol_V1_PolicyDecisionMade) -> Bool {
    if lhs.policyID != rhs.policyID {return false}
    if lhs.decision != rhs.decision {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ProposedActionCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposedActionCreated"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}tool\0\u{3}risk_class\0\u{1}identity\0\u{3}idempotency_key\0\u{1}justification\0\u{3}deterministic_summary\0\u{1}preview\0\u{3}expires_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tool) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.riskClass) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.idempotencyKey) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.justification) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.deterministicSummary) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._preview) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if !self.tool.isEmpty {
      try visitor.visitSingularStringField(value: self.tool, fieldNumber: 2)
    }
    if self.riskClass != .unspecified {
      try visitor.visitSingularEnumField(value: self.riskClass, fieldNumber: 3)
    }
    if self.identity != .unspecified {
      try visitor.visitSingularEnumField(value: self.identity, fieldNumber: 4)
    }
    if !self.idempotencyKey.isEmpty {
      try visitor.visitSingularStringField(value: self.idempotencyKey, fieldNumber: 5)
    }
    if !self.justification.isEmpty {
      try visitor.visitSingularStringField(value: self.justification, fieldNumber: 6)
    }
    if !self.deterministicSummary.isEmpty {
      try visitor.visitSingularStringField(value: self.deterministicSummary, fieldNumber: 7)
    }
    try { if let v = self._preview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ProposedActionCreated, rhs: Pincer_Protocol_V1_ProposedActionCreated) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.tool != rhs.tool {return false}
    if lhs.riskClass != rhs.riskClass {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.idempotencyKey != rhs.idempotencyKey {return false}
    if lhs.justification != rhs.justification {return false}
    if lhs.deterministicSummary != rhs.deterministicSummary {return false}
    if lhs._preview != rhs._preview {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ProposedActionStatusChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposedActionStatusChanged"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}status\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ProposedActionStatusChanged, rhs: Pincer_Protocol_V1_ProposedActionStatusChanged) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_IdempotencyConflict: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdempotencyConflict"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}tool\0\u{3}idempotency_key\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tool) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idempotencyKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if !self.tool.isEmpty {
      try visitor.visitSingularStringField(value: self.tool, fieldNumber: 2)
    }
    if !self.idempotencyKey.isEmpty {
      try visitor.visitSingularStringField(value: self.idempotencyKey, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_IdempotencyConflict, rhs: Pincer_Protocol_V1_IdempotencyConflict) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.tool != rhs.tool {return false}
    if lhs.idempotencyKey != rhs.idempotencyKey {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_JobStatusChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobStatusChanged"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_JobStatusChanged, rhs: Pincer_Protocol_V1_JobStatusChanged) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ScheduleTriggered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleTriggered"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0\u{3}scheduled_for_utc\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduledForUtc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    try { if let v = self._scheduledForUtc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ScheduleTriggered, rhs: Pincer_Protocol_V1_ScheduleTriggered) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._scheduledForUtc != rhs._scheduledForUtc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_DelegatedCallbackReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedCallbackReceived"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}callback_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callbackID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callbackID.isEmpty {
      try visitor.visitSingularStringField(value: self.callbackID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_DelegatedCallbackReceived, rhs: Pincer_Protocol_V1_DelegatedCallbackReceived) -> Bool {
    if lhs.callbackID != rhs.callbackID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_AuditEventRecorded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditEventRecorded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}entry_id\0\u{3}event_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryID.isEmpty {
      try visitor.visitSingularStringField(value: self.entryID, fieldNumber: 1)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_AuditEventRecorded, rhs: Pincer_Protocol_V1_AuditEventRecorded) -> Bool {
    if lhs.entryID != rhs.entryID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_NotificationQueued: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationQueued"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}notification_id\0\u{1}type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.notificationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationID, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_NotificationQueued, rhs: Pincer_Protocol_V1_NotificationQueued) -> Bool {
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ArtifactCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArtifactCreated"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}artifact_id\0\u{3}thread_id\0\u{3}media_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mediaType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if !self.mediaType.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ArtifactCreated, rhs: Pincer_Protocol_V1_ArtifactCreated) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_MemoryCheckpointSaved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemoryCheckpointSaved"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}checkpoint_id\0\u{1}scope\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.checkpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.checkpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.checkpointID, fieldNumber: 1)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_MemoryCheckpointSaved, rhs: Pincer_Protocol_V1_MemoryCheckpointSaved) -> Bool {
    if lhs.checkpointID != rhs.checkpointID {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_SkillProposalCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SkillProposalCreated"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}proposal_id\0\u{1}title\0\u{3}requires_owner_approval\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requiresOwnerApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposalID.isEmpty {
      try visitor.visitSingularStringField(value: self.proposalID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.requiresOwnerApproval != false {
      try visitor.visitSingularBoolField(value: self.requiresOwnerApproval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_SkillProposalCreated, rhs: Pincer_Protocol_V1_SkillProposalCreated) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.requiresOwnerApproval != rhs.requiresOwnerApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_SelfImprovementProposalCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfImprovementProposalCreated"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}proposal_id\0\u{1}kind\0\u{3}requires_owner_approval\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requiresOwnerApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposalID.isEmpty {
      try visitor.visitSingularStringField(value: self.proposalID, fieldNumber: 1)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 2)
    }
    if self.requiresOwnerApproval != false {
      try visitor.visitSingularBoolField(value: self.requiresOwnerApproval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_SelfImprovementProposalCreated, rhs: Pincer_Protocol_V1_SelfImprovementProposalCreated) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.requiresOwnerApproval != rhs.requiresOwnerApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Heartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Heartbeat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}latest_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.latestSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latestSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestSequence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Heartbeat, rhs: Pincer_Protocol_V1_Heartbeat) -> Bool {
    if lhs.latestSequence != rhs.latestSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_StreamGap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamGap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requested_from_sequence\0\u{3}next_available_sequence\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestedFromSequence) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nextAvailableSequence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestedFromSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestedFromSequence, fieldNumber: 1)
    }
    if self.nextAvailableSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.nextAvailableSequence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_StreamGap, rhs: Pincer_Protocol_V1_StreamGap) -> Bool {
    if lhs.requestedFromSequence != rhs.requestedFromSequence {return false}
    if lhs.nextAvailableSequence != rhs.nextAvailableSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Approval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Approval"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}source\0\u{3}source_id\0\u{1}tool\0\u{1}status\0\u{3}risk_class\0\u{1}identity\0\u{3}deterministic_summary\0\u{1}preview\0\u{3}created_at\0\u{3}expires_at\0\u{3}rejection_reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tool) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.riskClass) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.identity) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deterministicSummary) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._preview) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.rejectionReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if !self.sourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceID, fieldNumber: 3)
    }
    if !self.tool.isEmpty {
      try visitor.visitSingularStringField(value: self.tool, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.riskClass != .unspecified {
      try visitor.visitSingularEnumField(value: self.riskClass, fieldNumber: 6)
    }
    if self.identity != .unspecified {
      try visitor.visitSingularEnumField(value: self.identity, fieldNumber: 7)
    }
    if !self.deterministicSummary.isEmpty {
      try visitor.visitSingularStringField(value: self.deterministicSummary, fieldNumber: 8)
    }
    try { if let v = self._preview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.rejectionReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectionReason, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Approval, rhs: Pincer_Protocol_V1_Approval) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.tool != rhs.tool {return false}
    if lhs.status != rhs.status {return false}
    if lhs.riskClass != rhs.riskClass {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.deterministicSummary != rhs.deterministicSummary {return false}
    if lhs._preview != rhs._preview {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.rejectionReason != rhs.rejectionReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListApprovalsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApprovalsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListApprovalsRequest, rhs: Pincer_Protocol_V1_ListApprovalsRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListApprovalsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApprovalsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListApprovalsResponse, rhs: Pincer_Protocol_V1_ListApprovalsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ApproveActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApproveActionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ApproveActionRequest, rhs: Pincer_Protocol_V1_ApproveActionRequest) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ApproveActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApproveActionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ApproveActionResponse, rhs: Pincer_Protocol_V1_ApproveActionResponse) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RejectActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RejectActionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RejectActionRequest, rhs: Pincer_Protocol_V1_RejectActionRequest) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RejectActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RejectActionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_id\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RejectActionResponse, rhs: Pincer_Protocol_V1_RejectActionResponse) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Job: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Job"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}goal\0\u{1}status\0\u{3}thread_id\0\u{3}trigger_type\0\u{3}trigger_source_id\0\u{1}budget\0\u{3}max_wall_time_ms\0\u{3}last_error\0\u{3}created_at\0\u{3}updated_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.goal) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.triggerType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.triggerSourceID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._budget) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.maxWallTimeMs) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.lastError) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if !self.goal.isEmpty {
      try visitor.visitSingularStringField(value: self.goal, fieldNumber: 2)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 4)
    }
    if self.triggerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerType, fieldNumber: 5)
    }
    if !self.triggerSourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerSourceID, fieldNumber: 6)
    }
    try { if let v = self._budget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.maxWallTimeMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxWallTimeMs, fieldNumber: 8)
    }
    if !self.lastError.isEmpty {
      try visitor.visitSingularStringField(value: self.lastError, fieldNumber: 9)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Job, rhs: Pincer_Protocol_V1_Job) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.goal != rhs.goal {return false}
    if lhs.status != rhs.status {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.triggerType != rhs.triggerType {return false}
    if lhs.triggerSourceID != rhs.triggerSourceID {return false}
    if lhs._budget != rhs._budget {return false}
    if lhs.maxWallTimeMs != rhs.maxWallTimeMs {return false}
    if lhs.lastError != rhs.lastError {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListJobsRequest, rhs: Pincer_Protocol_V1_ListJobsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListJobsResponse, rhs: Pincer_Protocol_V1_ListJobsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateJobRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}goal\0\u{1}budget\0\u{3}max_wall_time_ms\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.goal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._budget) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxWallTimeMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.goal.isEmpty {
      try visitor.visitSingularStringField(value: self.goal, fieldNumber: 1)
    }
    try { if let v = self._budget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maxWallTimeMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxWallTimeMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateJobRequest, rhs: Pincer_Protocol_V1_CreateJobRequest) -> Bool {
    if lhs.goal != rhs.goal {return false}
    if lhs._budget != rhs._budget {return false}
    if lhs.maxWallTimeMs != rhs.maxWallTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateJobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateJobResponse, rhs: Pincer_Protocol_V1_CreateJobResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJobRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetJobRequest, rhs: Pincer_Protocol_V1_GetJobRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetJobResponse, rhs: Pincer_Protocol_V1_GetJobResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CancelJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelJobRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CancelJobRequest, rhs: Pincer_Protocol_V1_CancelJobRequest) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CancelJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelJobResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CancelJobResponse, rhs: Pincer_Protocol_V1_CancelJobResponse) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0\u{1}name\0\u{3}trigger_kind\0\u{3}trigger_spec\0\u{1}timezone\0\u{1}enabled\0\u{3}next_run_at\0\u{3}last_run_at\0\u{3}created_at\0\u{3}updated_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.triggerKind) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerSpec) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._nextRunAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._lastRunAt) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.triggerKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerKind, fieldNumber: 3)
    }
    if !self.triggerSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerSpec, fieldNumber: 4)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 5)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 6)
    }
    try { if let v = self._nextRunAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._lastRunAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Schedule, rhs: Pincer_Protocol_V1_Schedule) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.triggerKind != rhs.triggerKind {return false}
    if lhs.triggerSpec != rhs.triggerSpec {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs._nextRunAt != rhs._nextRunAt {return false}
    if lhs._lastRunAt != rhs._lastRunAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListSchedulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSchedulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListSchedulesRequest, rhs: Pincer_Protocol_V1_ListSchedulesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListSchedulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSchedulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListSchedulesResponse, rhs: Pincer_Protocol_V1_ListSchedulesResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}trigger_kind\0\u{3}trigger_spec\0\u{1}timezone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.triggerKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.triggerSpec) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.triggerKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.triggerKind, fieldNumber: 2)
    }
    if !self.triggerSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerSpec, fieldNumber: 3)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateScheduleRequest, rhs: Pincer_Protocol_V1_CreateScheduleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.triggerKind != rhs.triggerKind {return false}
    if lhs.triggerSpec != rhs.triggerSpec {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_CreateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_CreateScheduleResponse, rhs: Pincer_Protocol_V1_CreateScheduleResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_UpdateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0\u{1}patch\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._patch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    try { if let v = self._patch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_UpdateScheduleRequest, rhs: Pincer_Protocol_V1_UpdateScheduleRequest) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._patch != rhs._patch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_UpdateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_UpdateScheduleResponse, rhs: Pincer_Protocol_V1_UpdateScheduleResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RunScheduleNowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunScheduleNowRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RunScheduleNowRequest, rhs: Pincer_Protocol_V1_RunScheduleNowRequest) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_RunScheduleNowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunScheduleNowResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0\u{3}wakeup_event_id\0\u{3}job_id\0\u{3}turn_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wakeupEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.turnID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    if !self.wakeupEventID.isEmpty {
      try visitor.visitSingularStringField(value: self.wakeupEventID, fieldNumber: 2)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 3)
    }
    if !self.turnID.isEmpty {
      try visitor.visitSingularStringField(value: self.turnID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_RunScheduleNowResponse, rhs: Pincer_Protocol_V1_RunScheduleNowResponse) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.wakeupEventID != rhs.wakeupEventID {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.turnID != rhs.turnID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetPolicySummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPolicySummaryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetPolicySummaryRequest, rhs: Pincer_Protocol_V1_GetPolicySummaryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_GetPolicySummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPolicySummaryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}summary\0\u{3}policy_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._summary) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.policyVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._summary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.policyVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.policyVersion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_GetPolicySummaryResponse, rhs: Pincer_Protocol_V1_GetPolicySummaryResponse) -> Bool {
    if lhs._summary != rhs._summary {return false}
    if lhs.policyVersion != rhs.policyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_AuditEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}entry_id\0\u{3}event_type\0\u{3}thread_id\0\u{3}job_id\0\u{3}action_id\0\u{1}payload\0\u{3}occurred_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._occurredAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entryID.isEmpty {
      try visitor.visitSingularStringField(value: self.entryID, fieldNumber: 1)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 2)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 3)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 4)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 5)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._occurredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_AuditEntry, rhs: Pincer_Protocol_V1_AuditEntry) -> Bool {
    if lhs.entryID != rhs.entryID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._occurredAt != rhs._occurredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListAuditRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAuditRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListAuditRequest, rhs: Pincer_Protocol_V1_ListAuditRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListAuditResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAuditResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListAuditResponse, rhs: Pincer_Protocol_V1_ListAuditResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}notification_id\0\u{1}type\0\u{3}resource_kind\0\u{3}resource_id\0\u{3}created_at\0\u{3}read_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.notificationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceKind) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.notificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationID, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.resourceKind.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceKind, fieldNumber: 3)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._readAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_Notification, rhs: Pincer_Protocol_V1_Notification) -> Bool {
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.resourceKind != rhs.resourceKind {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListNotificationsRequest, rhs: Pincer_Protocol_V1_ListNotificationsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pincer_Protocol_V1_ListNotificationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pincer_Protocol_V1_ListNotificationsResponse, rhs: Pincer_Protocol_V1_ListNotificationsResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
